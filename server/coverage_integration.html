
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>automix: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">my-collection/server/pkg/automix/automix.go (2.6%)</option>
				
				<option value="file1">my-collection/server/pkg/bl/directories/directories.go (56.0%)</option>
				
				<option value="file2">my-collection/server/pkg/bl/items/highlights.go (5.0%)</option>
				
				<option value="file3">my-collection/server/pkg/bl/items/items.go (42.6%)</option>
				
				<option value="file4">my-collection/server/pkg/bl/items/sub_items.go (0.0%)</option>
				
				<option value="file5">my-collection/server/pkg/bl/special_tags/special_tags.go (100.0%)</option>
				
				<option value="file6">my-collection/server/pkg/bl/tag_annotations/tag_annotations.go (84.4%)</option>
				
				<option value="file7">my-collection/server/pkg/bl/tags/tags.go (65.6%)</option>
				
				<option value="file8">my-collection/server/pkg/bl/tags/tags_auto_image.go (5.4%)</option>
				
				<option value="file9">my-collection/server/pkg/db/db.go (68.6%)</option>
				
				<option value="file10">my-collection/server/pkg/db/db_logger.go (0.0%)</option>
				
				<option value="file11">my-collection/server/pkg/db/directories_dao.go (88.2%)</option>
				
				<option value="file12">my-collection/server/pkg/db/items_dao.go (64.9%)</option>
				
				<option value="file13">my-collection/server/pkg/db/tag_annotations_dao.go (100.0%)</option>
				
				<option value="file14">my-collection/server/pkg/db/tag_image_type.go (21.1%)</option>
				
				<option value="file15">my-collection/server/pkg/db/tags_custom_command_dao.go (25.0%)</option>
				
				<option value="file16">my-collection/server/pkg/db/tags_dao.go (69.4%)</option>
				
				<option value="file17">my-collection/server/pkg/db/tasks_dao.go (0.0%)</option>
				
				<option value="file18">my-collection/server/pkg/directorytree/compare.go (100.0%)</option>
				
				<option value="file19">my-collection/server/pkg/directorytree/diff.go (75.6%)</option>
				
				<option value="file20">my-collection/server/pkg/directorytree/stale.go (70.6%)</option>
				
				<option value="file21">my-collection/server/pkg/directorytree/tree.go (60.0%)</option>
				
				<option value="file22">my-collection/server/pkg/directorytree/tree_db_builder.go (90.6%)</option>
				
				<option value="file23">my-collection/server/pkg/directorytree/tree_fs_builder.go (81.0%)</option>
				
				<option value="file24">my-collection/server/pkg/fssync/cached_dig.go (83.3%)</option>
				
				<option value="file25">my-collection/server/pkg/fssync/fs_directory.go (82.6%)</option>
				
				<option value="file26">my-collection/server/pkg/fssync/fs_manager.go (58.8%)</option>
				
				<option value="file27">my-collection/server/pkg/fssync/fs_syncer.go (80.0%)</option>
				
				<option value="file28">my-collection/server/pkg/mixondemand/mixondemand.go (4.0%)</option>
				
				<option value="file29">my-collection/server/pkg/model/interfaces_mock.go (0.0%)</option>
				
				<option value="file30">my-collection/server/pkg/model/types.go (9.1%)</option>
				
				<option value="file31">my-collection/server/pkg/relativasor/path_relativasor.go (66.7%)</option>
				
				<option value="file32">my-collection/server/pkg/server/items/items_handler.go (57.6%)</option>
				
				<option value="file33">my-collection/server/pkg/server/server.go (0.0%)</option>
				
				<option value="file34">my-collection/server/pkg/server/server_util.go (33.3%)</option>
				
				<option value="file35">my-collection/server/pkg/server/tags/tags_handler.go (65.7%)</option>
				
				<option value="file36">my-collection/server/pkg/spectagger/cached_tarw.go (0.0%)</option>
				
				<option value="file37">my-collection/server/pkg/spectagger/spectagger.go (0.5%)</option>
				
				<option value="file38">my-collection/server/pkg/storage/storage.go (39.1%)</option>
				
				<option value="file39">my-collection/server/pkg/suggestions/suggestions.go (76.9%)</option>
				
				<option value="file40">my-collection/server/pkg/utils/fileutils.go (0.0%)</option>
				
				<option value="file41">my-collection/server/pkg/utils/logutils.go (45.0%)</option>
				
				<option value="file42">my-collection/server/pkg/utils/types.go (28.6%)</option>
				
				<option value="file43">my-collection/server/test/testutils/framework.go (75.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package automix

import (
        "context"
        "fmt"
        "my-collection/server/pkg/bl/items"
        "my-collection/server/pkg/bl/special_tags"
        "my-collection/server/pkg/bl/tag_annotations"
        "my-collection/server/pkg/bl/tags"
        "my-collection/server/pkg/model"
        "my-collection/server/pkg/utils"
        "time"
)

type autoMixDb interface {
        model.TagReaderWriter
        model.ItemReader
        model.TagAnnotationReaderWriter
}

func New(ctx context.Context, db autoMixDb, dailyMixItemsCount int) (*Automix, error) <span class="cov0" title="0">{
        d, err := db.GetTag(ctx, special_tags.DailymixTag)
        if err != nil </span><span class="cov0" title="0">{
                if err := db.CreateOrUpdateTag(ctx, special_tags.DailymixTag); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                special_tags.DailymixTag = d
        }</span>

        <span class="cov0" title="0">return &amp;Automix{
                db:                 db,
                dailyMixItemsCount: dailyMixItemsCount,
        }, nil</span>
}

type Automix struct {
        db                 autoMixDb
        dailyMixItemsCount int
        ctx                context.Context
}

func (d *Automix) Run(ctx context.Context) error <span class="cov0" title="0">{
        d.ctx = utils.ContextWithSubject(ctx, "automix")

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil</span>
                case &lt;-time.After(1 * time.Minute):<span class="cov0" title="0">
                        if !d.isDailymixExists(d.db, d) </span><span class="cov0" title="0">{
                                if err := d.generateDailymix(d); err != nil </span><span class="cov0" title="0">{
                                        utils.LogError("Error in generateDailymix", err)
                                }</span>
                        }
                }
        }
}

func (d *Automix) GetCurrentTime() time.Time <span class="cov0" title="0">{
        return time.Now()
}</span>

func (d *Automix) generateDailymix(ctg model.CurrentTimeGetter) error <span class="cov0" title="0">{
        if d.dailyMixItemsCount == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">tag, err := d.prepareDailymixTag(d.db, ctg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">randomItems, err := items.GetRandomItems(d.ctx, d.db, d.dailyMixItemsCount, func(item *model.Item) bool </span><span class="cov0" title="0">{
                isShortSubitem := items.IsSubItem(item) &amp;&amp; item.DurationSeconds &lt; 60*5
                return !items.IsHighlight(item) &amp;&amp; !items.IsSplittedItem(item) &amp;&amp; !isShortSubitem
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">tag.Items = randomItems
        return d.db.CreateOrUpdateTag(d.ctx, tag)</span>
}

func (d *Automix) isDailymixExists(db autoMixDb, ctg model.CurrentTimeGetter) bool <span class="cov0" title="0">{
        _, err := tags.GetChildTag(d.ctx, db, special_tags.DailymixTag.Id, getCurrentDailymixTitle(ctg))
        return err == nil
}</span>

func getCurrentDailymixTitle(ctg model.CurrentTimeGetter) string <span class="cov0" title="0">{
        return fmt.Sprintf("Mix %s", ctg.GetCurrentTime().Format("02-Jan-2006"))
}</span>

func getCurrentDailymixAnnotation(ctg model.CurrentTimeGetter) string <span class="cov0" title="0">{
        return ctg.GetCurrentTime().Format("Jan-2006")
}</span>

func (d *Automix) prepareDailymixTag(db autoMixDb, ctg model.CurrentTimeGetter) (*model.Tag, error) <span class="cov0" title="0">{
        tag, err := tags.GetOrCreateChildTag(d.ctx, db, special_tags.DailymixTag.Id, getCurrentDailymixTitle(ctg))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = tag_annotations.AddAnnotationToTag(d.ctx, db, db, tag.Id, model.TagAnnotation{
                Title: getCurrentDailymixAnnotation(ctg),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return tag, err</span>
}

func GetDailymixTagId() uint64 <span class="cov8" title="1">{
        return special_tags.DailymixTag.Id
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package directories

import (
        "context"
        "errors"
        "my-collection/server/pkg/model"
        "my-collection/server/pkg/relativasor"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/op/go-logging"
        "golang.org/x/text/cases"
        "golang.org/x/text/language"
        "gorm.io/gorm"
        "k8s.io/utils/pointer"
)

var directoriesTag = &amp;model.Tag{
        Title:    "Directories", // tags-utils.js
        ParentID: nil,
}

var logger = logging.MustGetLogger("directories")

func Init(ctx context.Context, trw model.TagReaderWriter) error <span class="cov8" title="1">{
        d, err := trw.GetTag(ctx, directoriesTag)
        if err != nil </span><span class="cov8" title="1">{
                if err := trw.CreateOrUpdateTag(ctx, directoriesTag); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                directoriesTag = d
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func ExcludeDirectory(ctx context.Context, drw model.DirectoryReaderWriter, path string) error <span class="cov8" title="1">{
        directory, err := GetDirectory(ctx, drw, NormalizeDirectoryPath(path))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if *directory.Excluded </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">directory.Excluded = pointer.Bool(true)
        directory.AutoIncludeChildren = pointer.Bool(false)
        directory.AutoIncludeHierarchy = pointer.Bool(false)
        return drw.CreateOrUpdateDirectory(ctx, directory)</span>
}

func IncludeOrCreateDirectory(ctx context.Context, drw model.DirectoryReaderWriter, path string) error <span class="cov8" title="1">{
        if err := IncludeDirectory(ctx, drw, path); err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        if err := CreateOrUpdateDirectory(ctx, drw, &amp;model.Directory{Path: path, Excluded: pointer.Bool(false)}); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func AutoIncludeHierarchy(ctx context.Context, drw model.DirectoryReaderWriter, path string) error <span class="cov8" title="1">{
        directory, err := GetDirectory(ctx, drw, NormalizeDirectoryPath(path))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if directory.AutoIncludeHierarchy != nil &amp;&amp; *directory.AutoIncludeHierarchy </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">directory.AutoIncludeHierarchy = pointer.Bool(true)
        return drw.CreateOrUpdateDirectory(ctx, directory)</span>
}

func AutoIncludeChildren(ctx context.Context, drw model.DirectoryReaderWriter, path string) error <span class="cov0" title="0">{
        directory, err := GetDirectory(ctx, drw, NormalizeDirectoryPath(path))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if directory.AutoIncludeChildren != nil &amp;&amp; *directory.AutoIncludeChildren </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">directory.AutoIncludeChildren = pointer.Bool(true)
        return drw.CreateOrUpdateDirectory(ctx, directory)</span>
}

func IncludeDirectory(ctx context.Context, drw model.DirectoryReaderWriter, path string) error <span class="cov8" title="1">{
        directory, err := GetDirectory(ctx, drw, NormalizeDirectoryPath(path))
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if !(*directory.Excluded) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">directory.Excluded = pointer.Bool(false)
        return drw.CreateOrUpdateDirectory(ctx, directory)</span>
}

func DirectoryNameToTag(path string) string <span class="cov8" title="1">{
        caser := cases.Title(language.English)
        return caser.String(strings.ReplaceAll(strings.ReplaceAll(filepath.Base(path), "-", " "), "_", " "))
}</span>

func TagTitleToDirectory(title string) string <span class="cov0" title="0">{
        return strings.ToLower(strings.ReplaceAll(title, " ", "-"))
}</span>

func TagExists(tags []*model.Tag, tag *model.Tag) bool <span class="cov0" title="0">{
        for _, t := range tags </span><span class="cov0" title="0">{
                if tag.Id == t.Id </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func RemoveMissingTags(ctx context.Context, drw model.DirectoryReaderWriter, directory *model.Directory, tags []*model.Tag) <span class="cov0" title="0">{
        for _, tag := range directory.Tags </span><span class="cov0" title="0">{
                if TagExists(tags, tag) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if err := drw.RemoveTagFromDirectory(ctx, directory.Path, tag.Id); err != nil </span><span class="cov0" title="0">{
                        logger.Warningf("Unable to remove tag %d from directory %s - %t",
                                directory.Path, tag.Id, err)
                }</span>
        }
}

func UpdateDirectoryTags(ctx context.Context, drw model.DirectoryReaderWriter, directory *model.Directory) error <span class="cov0" title="0">{
        existingDirectory, err := drw.GetDirectory(ctx, "path = ?", directory.Path)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error getting exising directory %s %t", directory.Path, err)
                return err
        }</span>

        <span class="cov0" title="0">RemoveMissingTags(ctx, drw, existingDirectory, directory.Tags)

        return drw.CreateOrUpdateDirectory(ctx, directory)</span>
}

func GetDirectory(ctx context.Context, dr model.DirectoryReader, path string) (*model.Directory, error) <span class="cov8" title="1">{
        return dr.GetDirectory(ctx, "path = ?", NormalizeDirectoryPath(path))
}</span>

func DirectoryExists(ctx context.Context, dr model.DirectoryReader, path string) (bool, error) <span class="cov8" title="1">{
        _, err := GetDirectory(ctx, dr, path)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>

                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov8" title="1">return true, nil</span>
}

func AddDirectory(ctx context.Context, dw model.DirectoryWriter, dir string, excluded bool) error <span class="cov8" title="1">{
        newDirectory := &amp;model.Directory{
                Path:     NormalizeDirectoryPath(dir),
                Excluded: pointer.Bool(excluded),
        }

        return dw.CreateOrUpdateDirectory(ctx, newDirectory)
}</span>

func ShouldInclude(ctx context.Context, dr model.DirectoryReader, path string) bool <span class="cov8" title="1">{
        dir, err := GetParent(ctx, dr, path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if dir.AutoIncludeChildren != nil &amp;&amp; *dir.AutoIncludeChildren </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                if dir.AutoIncludeHierarchy != nil &amp;&amp; *dir.AutoIncludeHierarchy </span><span class="cov8" title="1">{
                        return true
                }</span>

                <span class="cov8" title="1">dir, err = GetParent(ctx, dr, dir.Path)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">if dir == nil </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
}

func GetParent(ctx context.Context, dr model.DirectoryReader, path string) (*model.Directory, error) <span class="cov8" title="1">{
        if path == model.ROOT_DIRECTORY_PATH </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">parentPath := filepath.Dir(path)
        return GetDirectory(ctx, dr, parentPath)</span>
}

func AddDirectoryIfMissing(ctx context.Context, drw model.DirectoryReaderWriter, dir string, excluded bool) error <span class="cov8" title="1">{
        exists, err := DirectoryExists(ctx, drw, dir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return AddDirectory(ctx, drw, dir, excluded)</span>
}

func BuildDirectoryTags(directory *model.Directory) []*model.Tag <span class="cov8" title="1">{
        result := make([]*model.Tag, 0)
        title := DirectoryNameToTag(directory.Path)
        for _, directoryTag := range directory.Tags </span><span class="cov8" title="1">{
                result = append(result, &amp;model.Tag{ParentID: &amp;directoryTag.Id, Title: title})
        }</span>

        <span class="cov8" title="1">return result</span>
}

func AddRootDirectory(ctx context.Context, drw model.DirectoryReaderWriter) error <span class="cov8" title="1">{
        return AddDirectoryIfMissing(ctx, drw, model.ROOT_DIRECTORY_PATH, false)
}</span>

func NormalizeDirectoryPath(path string) string <span class="cov8" title="1">{
        normalizedPath := relativasor.GetRelativePath(path)

        if normalizedPath == "" </span><span class="cov8" title="1">{
                return model.ROOT_DIRECTORY_PATH
        }</span>

        <span class="cov8" title="1">return normalizedPath</span>
}

func CreateOrUpdateDirectory(ctx context.Context, dw model.DirectoryWriter, directory *model.Directory) error <span class="cov8" title="1">{
        directory.Excluded = pointer.Bool(false)
        directory.Path = NormalizeDirectoryPath(directory.Path)
        return dw.CreateOrUpdateDirectory(ctx, directory)
}</span>

func UpdatePath(ctx context.Context, dw model.DirectoryWriter, directory *model.Directory, newpath string) error <span class="cov8" title="1">{
        oldPath := directory.Path
        directory.Path = NormalizeDirectoryPath(newpath)
        if err := dw.CreateOrUpdateDirectory(ctx, directory); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return dw.RemoveDirectory(ctx, oldPath)</span>
}

func StartDirectoryProcessing(ctx context.Context, dw model.DirectoryWriter, directory *model.Directory) error <span class="cov0" title="0">{
        if directory.ProcessingStart != nil &amp;&amp; *directory.ProcessingStart != 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">directory.ProcessingStart = pointer.Int64(time.Now().UnixMilli())
        return dw.CreateOrUpdateDirectory(ctx, directory)</span>
}

func FinishDirectoryProcessing(ctx context.Context, dw model.DirectoryWriter, directory *model.Directory) error <span class="cov0" title="0">{
        directory.LastSynced = time.Now().UnixMilli()
        directory.ProcessingStart = pointer.Int64(0)
        return dw.CreateOrUpdateDirectory(ctx, directory)
}</span>

func GetDirectoryFiles(directory *model.Directory) ([]os.DirEntry, error) <span class="cov0" title="0">{
        path := relativasor.GetAbsoluteFile(directory.Path)
        files, err := os.ReadDir(path)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error getting directory files %s %s", path, err)
        }</span>

        <span class="cov0" title="0">return files, err</span>
}

func GetDirectoryFile(directory *model.Directory, filename string) string <span class="cov0" title="0">{
        path := relativasor.GetAbsoluteFile(directory.Path)
        return filepath.Join(path, filename)
}</span>

func IsExcluded(directory *model.Directory) bool <span class="cov8" title="1">{
        if directory.Excluded == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return *directory.Excluded</span>
}

func ValidateReadyDirectory(ctx context.Context, drw model.DirectoryReaderWriter, path string) (*model.Directory, error) <span class="cov8" title="1">{
        dirpath := NormalizeDirectoryPath(path)
        if err := AddDirectoryIfMissing(ctx, drw, dirpath, false); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">dir, err := GetDirectory(ctx, drw, dirpath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if IsExcluded(dir) </span><span class="cov8" title="1">{
                dir.Excluded = pointer.Bool(false)
                return dir, drw.CreateOrUpdateDirectory(ctx, dir)
        }</span>

        <span class="cov8" title="1">return dir, nil</span>
}

func GetDirectoriesTagId() uint64 <span class="cov8" title="1">{
        return directoriesTag.Id
}</span>

func EnrichFsNode(ctx context.Context, dr model.DirectoryReader, node *model.FsNode) (*model.FsNode, error) <span class="cov0" title="0">{
        dir, err := GetDirectory(ctx, dr, node.Path)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return node, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">node.DirInfo = dir

        for i := 0; i &lt; len(node.Children); i++ </span><span class="cov0" title="0">{
                child, err := EnrichFsNode(ctx, dr, node.Children[i])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">node.Children[i] = child</span>
        }

        <span class="cov0" title="0">return node, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package items

import (
        "context"
        "fmt"
        "my-collection/server/pkg/model"
)

var highlightsTag = &amp;model.Tag{
        Title:    "Highlights", // tags-utils.js
        ParentID: nil,
}

func InitHighlights(ctx context.Context, trw model.TagReaderWriter) error <span class="cov0" title="0">{
        h, err := trw.GetTag(ctx, highlightsTag)
        if err != nil </span><span class="cov0" title="0">{
                if err := trw.CreateOrUpdateTag(ctx, highlightsTag); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                highlightsTag = h
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func buildHighlightUrl(origin string, startPosition float64, endPosition float64) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-%f-%f", origin, startPosition, endPosition)
}</span>

func buildHighlight(item *model.Item, startPosition float64, endPosition float64, highlightId uint64) *model.Item <span class="cov0" title="0">{
        return &amp;model.Item{
                Title:           item.Title,
                Origin:          buildHighlightUrl(item.Origin, startPosition, endPosition),
                Url:             item.Url,
                StartPosition:   startPosition,
                EndPosition:     endPosition,
                Width:           item.Width,
                Height:          item.Height,
                DurationSeconds: endPosition - startPosition,
                VideoCodecName:  item.VideoCodecName,
                AudioCodecName:  item.AudioCodecName,
                LastModified:    item.LastModified,
                PreviewMode:     PREVIEW_FROM_START_POSITION,
                Tags:            []*model.Tag{{Id: highlightId}},
        }
}</span>

func MakeHighlight(ctx context.Context, irw model.ItemReaderWriter, itemId uint64, startPosition float64, endPosition float64, highlightId uint64) (*model.Item, error) <span class="cov0" title="0">{
        item, err := irw.GetItem(ctx, itemId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">highlight := buildHighlight(item, startPosition, endPosition, highlightId)
        if err := irw.CreateOrUpdateItem(ctx, highlight); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">item.Highlights = append(item.Highlights, highlight)
        if err := irw.UpdateItem(ctx, item); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return highlight, nil</span>
}

func IsHighlight(item *model.Item) bool <span class="cov0" title="0">{
        return item.HighlightParentItemId != nil
}</span>

func GetHighlightsTagId() uint64 <span class="cov8" title="1">{
        return highlightsTag.Id
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package items

import (
        "context"
        "fmt"
        "math/rand"
        "my-collection/server/pkg/model"
        "my-collection/server/pkg/relativasor"
        "os"
        "path/filepath"

        "github.com/go-errors/errors"

        "github.com/op/go-logging"
)

var logger = logging.MustGetLogger("items")

const PREVIEW_FROM_START_POSITION = "start-position" //items-util.js

type ItemsFilter func(item *model.Item) bool

func FileExists(item model.Item) bool <span class="cov0" title="0">{
        path := relativasor.GetAbsoluteFile(filepath.Join(item.Origin, item.Title))
        _, err := os.Stat(path)
        return err == nil
}</span>

func TitleFromFileName(path string) string <span class="cov8" title="1">{
        return filepath.Base(path)
}</span>

func BuildItemFromPath(origin string, path string, fmdg model.FileMetadataGetter) (*model.Item, error) <span class="cov8" title="1">{
        lastModified, fileSize, err := fmdg.GetFileMetadata(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">title := TitleFromFileName(path)
        return &amp;model.Item{
                Title:        title,
                Origin:       origin,
                Url:          filepath.Join(origin, title),
                LastModified: lastModified,
                FileSize:     fileSize,
        }, nil</span>
}

func UpdateFileLocation(ctx context.Context, iw model.ItemWriter, item *model.Item, origin string, path string, url string) error <span class="cov8" title="1">{
        title := TitleFromFileName(path)
        item.Origin = origin
        item.Title = title

        if url == "" </span><span class="cov8" title="1">{
                item.Url = filepath.Join(origin, title)
        }</span> else<span class="cov0" title="0"> {
                item.Url = url
        }</span>

        <span class="cov8" title="1">for _, highlight := range item.Highlights </span><span class="cov0" title="0">{
                highlightOrigin := buildHighlightUrl(origin, highlight.StartPosition, highlight.EndPosition)
                UpdateFileLocation(ctx, iw, highlight, highlightOrigin, path, item.Url)
        }</span>

        <span class="cov8" title="1">for _, subitem := range item.SubItems </span><span class="cov0" title="0">{
                subitemOrigin := buildSubItemOrigin(origin, subitem.StartPosition, subitem.EndPosition)
                UpdateFileLocation(ctx, iw, subitem, subitemOrigin, path, item.Url)
        }</span>

        <span class="cov8" title="1">return iw.UpdateItem(ctx, item)</span>
}

func ItemExists(items []*model.Item, item *model.Item) bool <span class="cov8" title="1">{
        for _, i := range items </span><span class="cov0" title="0">{
                if item.Id == i.Id </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func TagExists(tags []*model.Tag, tag *model.Tag) bool <span class="cov8" title="1">{
        for _, t := range tags </span><span class="cov8" title="1">{
                if tag.Id == t.Id </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func EnsureItemHaveTags(ctx context.Context, iw model.ItemWriter, item *model.Item, tags []*model.Tag) (bool, error) <span class="cov8" title="1">{
        missingTags := make([]*model.Tag, 0)
        for _, tag := range tags </span><span class="cov8" title="1">{
                if !TagExists(item.Tags, tag) </span><span class="cov8" title="1">{
                        missingTags = append(missingTags, tag)
                }</span>
        }

        <span class="cov8" title="1">if len(missingTags) == 0 </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">item.Tags = append(item.Tags, missingTags...)
        if err := iw.UpdateItem(ctx, item); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

func EnsureItemMissingTags(ctx context.Context, iw model.ItemWriter, item *model.Item, tags []*model.Tag) error <span class="cov0" title="0">{
        for _, tagToRemove := range tags </span><span class="cov0" title="0">{
                for _, tag := range item.Tags </span><span class="cov0" title="0">{
                        if tag.Id == tagToRemove.Id </span><span class="cov0" title="0">{
                                if err := iw.RemoveTagFromItem(ctx, item.Id, tag.Id); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func HasSingleTag(item *model.Item, tag *model.Tag) bool <span class="cov0" title="0">{
        return len(item.Tags) == 1 &amp;&amp; item.Tags[0].Id == tag.Id
}</span>

func RemoveItemAndItsAssociations(ctx context.Context, iw model.ItemWriter, itemId uint64) []error <span class="cov8" title="1">{
        errors := make([]error, 0)
        if err := iw.RemoveItem(ctx, itemId); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">return errors</span>
}

func DeleteRealFile(ctx context.Context, ir model.ItemReader, itemId uint64) error <span class="cov0" title="0">{
        item, err := ir.GetItem(ctx, itemId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if IsSubItem(item) </span><span class="cov0" title="0">{
                return errors.Errorf("Deletion of subitem is forbidden")
        }</span>

        <span class="cov0" title="0">if IsHighlight(item) </span><span class="cov0" title="0">{
                return errors.Errorf("Deletion of highlight is forbidden")
        }</span>

        <span class="cov0" title="0">file := relativasor.GetAbsoluteFile(item.Url)
        logger.Infof("About to delete real file %s", file)
        if err := os.Remove(file); err != nil </span><span class="cov0" title="0">{
                logger.Warningf("Unable to delete file %s, %s", file, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func noRandom(item *model.Item) bool <span class="cov0" title="0">{
        for _, tag := range item.Tags </span><span class="cov0" title="0">{
                if tag.NoRandom != nil &amp;&amp; *tag.NoRandom </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func GetRandomItems(ctx context.Context, ir model.ItemReader, count int, filter ItemsFilter) ([]*model.Item, error) <span class="cov8" title="1">{
        allItems, err := ir.GetAllItems(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(*allItems) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no items")
        }</span>
        <span class="cov8" title="1">if count &gt;= len(*allItems) </span><span class="cov8" title="1">{
                count = len(*allItems) - 1
        }</span>

        <span class="cov8" title="1">randomItems := make([]*model.Item, 0)
        maxAttempts := len(*allItems) * 10 // Safety limit to prevent infinite loops

        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                attempts := 0
                var chosenItem *model.Item

                for </span><span class="cov0" title="0">{
                        if attempts &gt;= maxAttempts </span><span class="cov0" title="0">{
                                // If we can't find enough valid items, return what we have
                                break</span>
                        }

                        <span class="cov0" title="0">chosenItem = &amp;((*allItems)[rand.Intn(len(*allItems))])

                        // Check if this item is suitable
                        if !ItemExists(randomItems, chosenItem) &amp;&amp; filter(chosenItem) &amp;&amp; !noRandom(chosenItem) </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov0" title="0">attempts++</span>
                }

                // Only add the item if we found a valid one
                <span class="cov0" title="0">if attempts &lt; maxAttempts </span><span class="cov0" title="0">{
                        randomItems = append(randomItems, chosenItem)
                }</span>
        }

        <span class="cov8" title="1">return randomItems, nil</span>
}

func IsModified(item *model.Item, fmg model.FileMetadataGetter) (bool, error) <span class="cov0" title="0">{
        path := relativasor.GetAbsoluteFile(filepath.Join(item.Origin, item.Title))
        lastModified, _, err := fmg.GetFileMetadata(path)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return item.LastModified != lastModified, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package items

import (
        "context"
        "fmt"
        "my-collection/server/pkg/model"

        "github.com/go-errors/errors"
)

func buildSubItemOrigin(origin string, startPosition float64, endPosition float64) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-%f-%f", origin, startPosition, endPosition)
}</span>

func buildSubItem(item *model.Item, startPosition float64, endPosition float64) *model.Item <span class="cov0" title="0">{
        return &amp;model.Item{
                Title:           item.Title,
                Origin:          buildSubItemOrigin(item.Origin, startPosition, endPosition),
                Url:             item.Url,
                StartPosition:   startPosition,
                EndPosition:     endPosition,
                Width:           item.Width,
                Height:          item.Height,
                DurationSeconds: endPosition - startPosition,
                VideoCodecName:  item.VideoCodecName,
                AudioCodecName:  item.AudioCodecName,
                LastModified:    item.LastModified,
        }
}</span>

func GetMainItem(ctx context.Context, ir model.ItemReader, itemId uint64) (*model.Item, error) <span class="cov0" title="0">{
        item, err := ir.GetItem(ctx, itemId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for IsSubItem(item) </span><span class="cov0" title="0">{
                item, err = ir.GetItem(ctx, item.MainItemId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return item, nil</span>
}

func GetContainedSubItem(mainItem *model.Item, second float64) (*model.Item, error) <span class="cov0" title="0">{
        if len(mainItem.SubItems) == 0 </span><span class="cov0" title="0">{
                return mainItem, nil
        }</span>

        <span class="cov0" title="0">for _, subItem := range mainItem.SubItems </span><span class="cov0" title="0">{
                if subItem.StartPosition &lt;= second &amp;&amp; subItem.EndPosition &gt;= second </span><span class="cov0" title="0">{
                        return subItem, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, errors.Errorf("sub-item at second %f not found in %v", second, mainItem)</span>
}

func splitMain(ctx context.Context, iw model.ItemWriter, mainItem *model.Item, second float64) ([]*model.Item, error) <span class="cov0" title="0">{
        sub1 := buildSubItem(mainItem, 0, second)
        sub2 := buildSubItem(mainItem, second, float64(mainItem.DurationSeconds))
        if err := iw.CreateOrUpdateItem(ctx, sub1); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := iw.CreateOrUpdateItem(ctx, sub2); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">mainItem.SubItems = append(mainItem.SubItems, sub1, sub2)
        changedItems := []*model.Item{sub1, sub2}
        return changedItems, nil</span>
}

func shrinkAndSplit(ctx context.Context, iw model.ItemWriter, mainItem *model.Item, containedItem *model.Item, second float64) ([]*model.Item, error) <span class="cov0" title="0">{
        sub := buildSubItem(mainItem, second, containedItem.EndPosition)
        if err := iw.CreateOrUpdateItem(ctx, sub); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">containedItem.EndPosition = second
        containedItem.DurationSeconds = containedItem.EndPosition - containedItem.StartPosition
        if err := iw.UpdateItem(ctx, containedItem); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">mainItem.SubItems = append(mainItem.SubItems, sub)
        changedItems := []*model.Item{sub, containedItem}
        return changedItems, nil</span>
}

func Split(ctx context.Context, irw model.ItemReaderWriter, itemId uint64, second float64) ([]*model.Item, error) <span class="cov0" title="0">{
        mainItem, err := GetMainItem(ctx, irw, itemId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">containedItem, err := GetContainedSubItem(mainItem, second)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var changedItems []*model.Item
        if IsSubItem(containedItem) </span><span class="cov0" title="0">{
                changedItems, err = shrinkAndSplit(ctx, irw, mainItem, containedItem, second)
        }</span> else<span class="cov0" title="0"> {
                changedItems, err = splitMain(ctx, irw, mainItem, second)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return changedItems, irw.UpdateItem(ctx, mainItem)</span>
}

func IsSubItem(item *model.Item) bool <span class="cov0" title="0">{
        return item.MainItemId != nil
}</span>

func IsSplittedItem(item *model.Item) bool <span class="cov0" title="0">{
        return len(item.SubItems) &gt; 0
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package special_tags

import (
        "my-collection/server/pkg/model"
)

var DailymixTag = &amp;model.Tag{
        Title:    "DailyMix", // tags-utils.js
        ParentID: nil,
}

var MixOnDemandTag = &amp;model.Tag{
        Title:    "Mod", // tags-utils.js
        ParentID: nil,
}

var SpecTag = &amp;model.Tag{
        Title:          "Spec", // tags-utils.js
        ParentID:       nil,
        DisplayStyle:   "chip",
        DefaultSorting: "items-count",
}

func IsSpecial(tagId uint64) bool <span class="cov8" title="1">{
        return tagId == DailymixTag.Id || tagId == SpecTag.Id || tagId == MixOnDemandTag.Id
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package tag_annotations

import (
        "context"
        "errors"
        "my-collection/server/pkg/model"

        "gorm.io/gorm"
)

func GetOrCreateTagAnnoation(ctx context.Context, tarw model.TagAnnotationReaderWriter, a *model.TagAnnotation) (*model.TagAnnotation, error) <span class="cov8" title="1">{
        annotation, err := tarw.GetTagAnnotation(ctx, a)

        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                err = tarw.CreateTagAnnotation(ctx, a)
                if err != nil </span><span class="cov0" title="0">{
                        return a, err
                }</span>

                <span class="cov8" title="1">annotation = a</span>
        }

        <span class="cov8" title="1">return annotation, nil</span>
}

func AddAnnotationToTag(ctx context.Context, trw model.TagReaderWriter, tarw model.TagAnnotationReaderWriter,
        tagId uint64, a model.TagAnnotation) (uint64, error) <span class="cov8" title="1">{
        annotation, err := GetOrCreateTagAnnoation(ctx, tarw, &amp;a)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">tag, err := trw.GetTag(ctx, tagId)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">tag.Annotations = append(tag.Annotations, annotation)
        return annotation.Id, trw.CreateOrUpdateTag(ctx, tag)</span>
}

func GetTagAvailableAnnotations(ctx context.Context, tr model.TagReader, tar model.TagAnnotationReader, tagId uint64) ([]model.TagAnnotation, error) <span class="cov8" title="1">{
        tag, err := tr.GetTag(ctx, tagId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">availableAnnotations := make(map[uint64]model.TagAnnotation)
        allRelevantTags := make([]*model.Tag, 0)
        allRelevantTags = append(allRelevantTags, tag)
        allRelevantTags = append(allRelevantTags, tag.Children...)
        for _, child := range allRelevantTags </span><span class="cov8" title="1">{
                annotations, err := tar.GetTagAnnotations(ctx, child.Id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">for _, annotation := range annotations </span><span class="cov8" title="1">{
                        availableAnnotations[annotation.Id] = annotation
                }</span>
        }

        <span class="cov8" title="1">result := make([]model.TagAnnotation, 0, len(availableAnnotations))
        for _, v := range availableAnnotations </span><span class="cov8" title="1">{
                result = append(result, v)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package tags

import (
        "context"
        "errors"
        "my-collection/server/pkg/model"

        "github.com/op/go-logging"
        "gorm.io/gorm"
)

var logger = logging.MustGetLogger("tags")

func GetItems(ctx context.Context, ir model.ItemReader, tag *model.Tag) (*[]model.Item, error) <span class="cov8" title="1">{
        itemIds := make([]uint64, 0)
        for _, item := range tag.Items </span><span class="cov8" title="1">{
                itemIds = append(itemIds, item.Id)
        }</span>

        <span class="cov8" title="1">if len(itemIds) == 0 </span><span class="cov8" title="1">{
                result := make([]model.Item, 0)
                return &amp;result, nil
        }</span>

        <span class="cov8" title="1">items, err := ir.GetItems(ctx, itemIds)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error getting items of tag %t", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return items, nil</span>
}

func GetItemByTitle(ctx context.Context, ir model.ItemReader, tag *model.Tag, title string) (*model.Item, error) <span class="cov8" title="1">{
        items, err := GetItems(ctx, ir, tag)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, item := range *items </span><span class="cov8" title="1">{
                if item.Title == title </span><span class="cov8" title="1">{
                        return &amp;item, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, nil</span>
}

func GetOrCreateTag(ctx context.Context, trw model.TagReaderWriter, tag *model.Tag) (*model.Tag, error) <span class="cov8" title="1">{
        existing, err := trw.GetTag(ctx, tag)
        if err != nil &amp;&amp; !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                logger.Errorf("Error getting tag %t", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if existing != nil &amp;&amp; !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                return existing, nil
        }</span>

        <span class="cov8" title="1">if err := trw.CreateOrUpdateTag(ctx, tag); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error creating tag %v - %t", tag, err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return tag, nil</span>
}

func GetOrCreateChildTag(ctx context.Context, trw model.TagReaderWriter, parentId uint64, title string) (*model.Tag, error) <span class="cov8" title="1">{
        tag := model.Tag{
                ParentID: &amp;parentId,
                Title:    title,
        }

        return GetOrCreateTag(ctx, trw, &amp;tag)
}</span>

func GetChildTag(ctx context.Context, tr model.TagReader, parentId uint64, title string) (*model.Tag, error) <span class="cov8" title="1">{
        tag := model.Tag{
                ParentID: &amp;parentId,
                Title:    title,
        }

        return tr.GetTag(ctx, tag)
}</span>

func GetOrCreateTags(ctx context.Context, trw model.TagReaderWriter, tags []*model.Tag) ([]*model.Tag, error) <span class="cov8" title="1">{
        result := make([]*model.Tag, 0)

        for _, tag := range tags </span><span class="cov8" title="1">{
                tag, err := GetOrCreateTag(ctx, trw, tag)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">result = append(result, tag)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

func RemoveTagAndItsAssociations(ctx context.Context, tw model.TagWriter, tag *model.Tag) []error <span class="cov8" title="1">{
        errors := make([]error, 0)
        if err := tw.RemoveTag(ctx, tag.Id); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov8" title="1">return errors</span>
}

func GetFullTags(ctx context.Context, tr model.TagReader, tagIds []*model.Tag) (*[]model.Tag, error) <span class="cov8" title="1">{
        ids := make([]uint64, len(tagIds))
        for i, tag := range tagIds </span><span class="cov8" title="1">{
                ids[i] = tag.Id
        }</span>

        <span class="cov8" title="1">if len(ids) == 0 </span><span class="cov0" title="0">{
                result := make([]model.Tag, 0)
                return &amp;result, nil
        }</span>

        <span class="cov8" title="1">return tr.GetTags(ctx, ids)</span>
}

func GetCategories(ctx context.Context, tr model.TagReader) (*[]model.Tag, error) <span class="cov8" title="1">{
        return tr.GetTags(ctx, "parent_id is NULL")
}</span>

func IsBelongToCategory(tag *model.Tag, category *model.Tag) bool <span class="cov0" title="0">{
        return tag.ParentID != nil &amp;&amp; *tag.ParentID == category.Id
}</span>

func RemoveTagImages(ctx context.Context, trw model.TagReaderWriter, tagId uint64, titId uint64) error <span class="cov0" title="0">{
        tag, err := trw.GetTag(ctx, tagId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, image := range tag.Images </span><span class="cov0" title="0">{
                if image.ImageTypeId != titId </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if err := trw.RemoveTagImageFromTag(ctx, tagId, image.Id); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package tags

import (
        "context"
        "fmt"
        "my-collection/server/pkg/bl/directories"
        "my-collection/server/pkg/model"
        "os"
        "path/filepath"
        "time"

        "github.com/go-errors/errors"
        cp "github.com/otiai10/copy"
        "gorm.io/gorm"
)

func AutoImageChildren(ctx context.Context, storage model.StorageUploader, trw model.TagReaderWriter,
        titrw model.TagImageTypeReaderWriter, tag *model.Tag, directoryPath string) error <span class="cov8" title="1">{
        dirs, err := os.ReadDir(directoryPath)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, 0)
        }</span>

        <span class="cov8" title="1">for _, slimChildTag := range tag.Children </span><span class="cov0" title="0">{
                childTag, err := trw.GetTag(ctx, slimChildTag.Id)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Error getting tag %v - %t", slimChildTag, err)
                }</span>

                <span class="cov0" title="0">for _, dir := range dirs </span><span class="cov0" title="0">{
                        if !dir.IsDir() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">imageTypePath := filepath.Join(directoryPath, dir.Name())
                        if err := autoImageTagType(ctx, storage, trw, titrw, childTag, imageTypePath, dir.Name()); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("Error auto tagging %v from %s - %t", tag, imageTypePath, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func autoImageTagType(ctx context.Context, storage model.StorageUploader, tw model.TagWriter,
        titrw model.TagImageTypeReaderWriter, tag *model.Tag, directoryPath string, nickname string) error <span class="cov0" title="0">{
        tit, err := getOrCreateTagImageType(ctx, titrw, nickname)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Unable to get tag image type for %s - %s", nickname, err)
                return err
        }</span>

        <span class="cov0" title="0">if err := updateTagImageTypeIcon(ctx, storage, titrw, tit, directoryPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return autoImageTag(ctx, storage, tw, tag, directoryPath, tit)</span>
}

func updateTagImageTypeIcon(ctx context.Context, storage model.StorageUploader, titrw model.TagImageTypeReaderWriter, tit *model.TagImageType, directoryPath string) error <span class="cov0" title="0">{
        if tit.IconUrl != "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">path, err := findExistingImage("icon", directoryPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if path == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">relativeFile := filepath.Join("tit-icon", fmt.Sprint(tit.Id), filepath.Base(path))
        storageFile, err := storage.GetFileForWriting(relativeFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = cp.Copy(path, storageFile); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error coping tit icon %s to %s - %s", path, storageFile, err)
                return nil
        }</span>

        <span class="cov0" title="0">tit.IconUrl = storage.GetStorageUrl(relativeFile)
        return titrw.CreateOrUpdateTagImageType(ctx, tit)</span>
}

func imageExists(tag *model.Tag, tit *model.TagImageType) bool <span class="cov0" title="0">{
        for _, image := range tag.Images </span><span class="cov0" title="0">{
                if image.ImageTypeId == tit.Id </span><span class="cov0" title="0">{
                        return image.Url != "" &amp;&amp; image.Url != "none"
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func getOrCreateTagImageType(ctx context.Context, titrw model.TagImageTypeReaderWriter, nickname string) (*model.TagImageType, error) <span class="cov0" title="0">{
        tit, err := titrw.GetTagImageType(ctx, "nickname = ?", nickname)
        if err != nil &amp;&amp; !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                return tit, nil
        }</span>

        <span class="cov0" title="0">tit = &amp;model.TagImageType{
                Nickname: nickname,
        }

        if err := titrw.CreateOrUpdateTagImageType(ctx, tit); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return tit, nil</span>
}

func autoImageTag(ctx context.Context, storage model.StorageUploader, tw model.TagWriter, tag *model.Tag,
        directoryPath string, tit *model.TagImageType) error <span class="cov0" title="0">{
        path, err := findExistingImage(tag.Title, directoryPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if path == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">relativeFile := filepath.Join("tags-image-types", fmt.Sprint(tag.Id), fmt.Sprint(tit.Id), filepath.Base(path))
        storageFile, err := storage.GetFileForWriting(relativeFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err = cp.Copy(path, storageFile); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error coping %s to %s - %t", path, storageFile, err)
                return nil
        }</span>

        <span class="cov0" title="0">if !imageExists(tag, tit) </span><span class="cov0" title="0">{
                tag.Images = append(tag.Images, &amp;model.TagImage{
                        TagId:       tag.Id,
                        Url:         storage.GetStorageUrl(relativeFile),
                        ImageNonce:  time.Now().UnixNano(),
                        ImageTypeId: tit.Id,
                })
        }</span>

        <span class="cov0" title="0">return tw.CreateOrUpdateTag(ctx, tag)</span>
}

func findExistingImage(tagTitle string, directory string) (string, error) <span class="cov0" title="0">{
        possiblePaths := []string{
                filepath.Join(directory, tagTitle),
                filepath.Join(directory, directories.TagTitleToDirectory(tagTitle)),
        }

        possibleExtenssions := []string{"jpg", "png", "svg"}

        for _, pathWithoutExt := range possiblePaths </span><span class="cov0" title="0">{
                for _, ext := range possibleExtenssions </span><span class="cov0" title="0">{
                        path := fmt.Sprintf("%s.%s", pathWithoutExt, ext)
                        if _, err := os.Stat(path); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">return path, nil</span>
                }
        }

        <span class="cov0" title="0">return "", nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package db

import (
        "context"
        "log"
        "my-collection/server/pkg/model"
        "os"
        "time"

        "github.com/go-errors/errors"
        "github.com/op/go-logging"

        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
        gormlogger "gorm.io/gorm/logger"
)

var logger = logging.MustGetLogger("db")

type databaseImpl struct {
        db *gorm.DB
}

func New(dbfile string, shouldLog bool) (Database, error) <span class="cov8" title="1">{
        newLogger := gormlogger.New(
                log.New(os.Stdout, "\r\n", log.LstdFlags), // io writer
                gormlogger.Config{
                        SlowThreshold:             time.Second,       // Slow SQL threshold
                        LogLevel:                  gormlogger.Silent, // Log level
                        IgnoreRecordNotFoundError: true,              // Ignore ErrRecordNotFound error for logger
                        Colorful:                  false,             // Disable color
                },
        )
        db, err := gorm.Open(sqlite.Open(dbfile), &amp;gorm.Config{
                Logger: newLogger,
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, 0)
        }</span>

        <span class="cov8" title="1">if err = db.AutoMigrate(&amp;model.Item{}); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, 0)
        }</span>

        <span class="cov8" title="1">if err = db.AutoMigrate(&amp;model.Tag{}); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, 0)
        }</span>

        <span class="cov8" title="1">if err = db.AutoMigrate(&amp;model.Cover{}); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, 0)
        }</span>

        <span class="cov8" title="1">if err = db.AutoMigrate(&amp;model.TagAnnotation{}); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, 0)
        }</span>

        <span class="cov8" title="1">if err = db.AutoMigrate(&amp;model.Directory{}); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, 0)
        }</span>

        <span class="cov8" title="1">if err = db.AutoMigrate(&amp;model.Task{}); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, 0)
        }</span>

        <span class="cov8" title="1">if err = db.AutoMigrate(&amp;model.TagImageType{}); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, 0)
        }</span>

        <span class="cov8" title="1">if err = db.AutoMigrate(&amp;model.TagImage{}); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, 0)
        }</span>

        <span class="cov8" title="1">if err = db.AutoMigrate(&amp;model.TagCustomCommand{}); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, 0)
        }</span>

        <span class="cov8" title="1">logger.Infof("DB initialized with db file: %s", dbfile)

        result := &amp;databaseImpl{
                db: db,
        }
        if shouldLog </span><span class="cov0" title="0">{
                return &amp;dbLogger{
                        db: result,
                }, nil
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func (d *databaseImpl) handleError(err error) error <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, 1)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (d *databaseImpl) deleteAssociation(ctx context.Context, value interface{}, association interface{}, name string) error <span class="cov8" title="1">{
        return d.handleError(d.db.WithContext(ctx).Model(value).Association(name).Delete(association))
}</span>

func (d *databaseImpl) delete(ctx context.Context, value interface{}, conds ...interface{}) error <span class="cov8" title="1">{
        return d.handleError(d.db.WithContext(ctx).Delete(value, conds...).Error)
}</span>

func (d *databaseImpl) deleteWithAssociations(ctx context.Context, value interface{}, conds ...interface{}) error <span class="cov8" title="1">{
        return d.handleError(d.db.WithContext(ctx).Select(clause.Associations).Delete(value, conds...).Error)
}</span>

func (d *databaseImpl) create(ctx context.Context, value interface{}) error <span class="cov8" title="1">{
        return d.handleError(d.db.WithContext(ctx).Create(value).Error)
}</span>

func (d *databaseImpl) update(ctx context.Context, value interface{}) error <span class="cov8" title="1">{
        return d.handleError(d.db.WithContext(ctx).Updates(value).Error)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package db

import (
        "context"
        "fmt"
        "my-collection/server/pkg/model"
        "my-collection/server/pkg/utils"
        "time"

        "github.com/op/go-logging"
)

var l = logging.MustGetLogger("db-logger")

type dbLogger struct {
        db *databaseImpl
}

func (d *dbLogger) log(ctx context.Context, operation string, start time.Time, err error, result interface{}) <span class="cov0" title="0">{
        duration := time.Since(start)
        ms := duration.Milliseconds()

        // Format duration with fixed width (6 chars: "1200ms")
        durationStr := fmt.Sprintf("%4dms", ms)

        // Format operation name with fixed width (20 chars)
        opStr := fmt.Sprintf("%-20s", operation)

        subject := utils.GetSubject(ctx)
        subjectStr := fmt.Sprintf("%-20s", subject)

        if err != nil </span><span class="cov0" title="0">{
                l.Errorf("[%s] %s %s error: %v", subjectStr, durationStr, opStr, err)
                return
        }</span>

        // Format result description
        <span class="cov0" title="0">resultStr := formatResult(result)
        l.Debugf("[%s] %s %s %s", subjectStr, durationStr, opStr, resultStr)</span>
}

func formatResult(result interface{}) string <span class="cov0" title="0">{
        if result == nil </span><span class="cov0" title="0">{
                return "ok"
        }</span>

        <span class="cov0" title="0">switch v := result.(type) </span>{
        case *model.Directory:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return "not found"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("dir: %s", v.Path)</span>
        case *[]model.Directory:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return "empty"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d dirs", len(*v))</span>
        case *model.Item:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return "not found"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("item id=%d", v.Id)</span>
        case *[]model.Item:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return "empty"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d items", len(*v))</span>
        case *model.Tag:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return "not found"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("tag id=%d", v.Id)</span>
        case *[]model.Tag:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return "empty"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d tags", len(*v))</span>
        case *model.TagAnnotation:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return "not found"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("annotation id=%d", v.Id)</span>
        case []model.TagAnnotation:<span class="cov0" title="0">
                return fmt.Sprintf("%d annotations", len(v))</span>
        case *model.TagImageType:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return "not found"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("image type id=%d", v.Id)</span>
        case *[]model.TagImageType:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return "empty"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d image types", len(*v))</span>
        case *[]model.TagCustomCommand:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return "empty"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d commands", len(*v))</span>
        case *[]model.Task:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return "empty"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d tasks", len(*v))</span>
        case *model.Task:<span class="cov0" title="0">
                if v == nil </span><span class="cov0" title="0">{
                        return "not found"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("task id=%s", v.Id)</span>
        case int64:<span class="cov0" title="0">
                return fmt.Sprintf("count=%d", v)</span>
        case float64:<span class="cov0" title="0">
                return fmt.Sprintf("%.2f", v)</span>
        default:<span class="cov0" title="0">
                return "ok"</span>
        }
}

// Directory operations
func (d *dbLogger) CreateOrUpdateDirectory(ctx context.Context, directory *model.Directory) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.CreateOrUpdateDirectory(ctx, directory)
        d.log(ctx, "CreateUpdateDir", start, err, directory)
        return err
}</span>

func (d *dbLogger) UpdateDirectory(ctx context.Context, directory *model.Directory) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.UpdateDirectory(ctx, directory)
        d.log(ctx, "UpdateDir", start, err, directory)
        return err
}</span>

func (d *dbLogger) RemoveDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.RemoveDirectory(ctx, path)
        d.log(ctx, "RemoveDir", start, err, fmt.Sprintf("path=%s", path))
        return err
}</span>

func (d *dbLogger) RemoveTagFromDirectory(ctx context.Context, directoryPath string, tagId uint64) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.RemoveTagFromDirectory(ctx, directoryPath, tagId)
        d.log(ctx, "RemoveTagFromDir", start, err, fmt.Sprintf("tag=%d", tagId))
        return err
}</span>

func (d *dbLogger) GetDirectory(ctx context.Context, conds ...interface{}) (*model.Directory, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetDirectory(ctx, conds...)
        d.log(ctx, "GetDir", start, err, result)
        return result, err
}</span>

func (d *dbLogger) GetDirectories(ctx context.Context, conds ...interface{}) (*[]model.Directory, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetDirectories(ctx, conds...)
        d.log(ctx, "GetDirs", start, err, result)
        return result, err
}</span>

func (d *dbLogger) GetAllDirectories(ctx context.Context) (*[]model.Directory, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetAllDirectories(ctx)
        d.log(ctx, "GetAllDirs", start, err, result)
        return result, err
}</span>

// Item operations
func (d *dbLogger) CreateOrUpdateItem(ctx context.Context, item *model.Item) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.CreateOrUpdateItem(ctx, item)
        d.log(ctx, "CreateUpdateItem", start, err, item)
        return err
}</span>

func (d *dbLogger) UpdateItem(ctx context.Context, item *model.Item) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.UpdateItem(ctx, item)
        d.log(ctx, "UpdateItem", start, err, item)
        return err
}</span>

func (d *dbLogger) RemoveItem(ctx context.Context, itemId uint64) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.RemoveItem(ctx, itemId)
        d.log(ctx, "RemoveItem", start, err, fmt.Sprintf("id=%d", itemId))
        return err
}</span>

func (d *dbLogger) RemoveTagFromItem(ctx context.Context, itemId uint64, tagId uint64) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.RemoveTagFromItem(ctx, itemId, tagId)
        d.log(ctx, "RemoveTagFromItem", start, err, fmt.Sprintf("item=%d tag=%d", itemId, tagId))
        return err
}</span>

func (d *dbLogger) GetItem(ctx context.Context, conds ...interface{}) (*model.Item, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetItem(ctx, conds...)
        d.log(ctx, "GetItem", start, err, result)
        return result, err
}</span>

func (d *dbLogger) GetItems(ctx context.Context, conds ...interface{}) (*[]model.Item, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetItems(ctx, conds...)
        d.log(ctx, "GetItems", start, err, result)
        return result, err
}</span>

func (d *dbLogger) GetAllItems(ctx context.Context) (*[]model.Item, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetAllItems(ctx)
        d.log(ctx, "GetAllItems", start, err, result)
        return result, err
}</span>

func (d *dbLogger) GetItemsCount(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetItemsCount(ctx)
        d.log(ctx, "GetItemsCount", start, err, result)
        return result, err
}</span>

func (d *dbLogger) GetTotalDurationSeconds(ctx context.Context) (float64, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetTotalDurationSeconds(ctx)
        d.log(ctx, "GetTotalDuration", start, err, result)
        return result, err
}</span>

// Tag Annotation operations
func (d *dbLogger) CreateTagAnnotation(ctx context.Context, tagAnnotation *model.TagAnnotation) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.CreateTagAnnotation(ctx, tagAnnotation)
        d.log(ctx, "CreateAnnotation", start, err, tagAnnotation)
        return err
}</span>

func (d *dbLogger) RemoveTag(ctx context.Context, tagId uint64) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.RemoveTag(ctx, tagId)
        d.log(ctx, "RemoveTag", start, err, fmt.Sprintf("id=%d", tagId))
        return err
}</span>

func (d *dbLogger) RemoveTagAnnotationFromTag(ctx context.Context, tagId uint64, annotationId uint64) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.RemoveTagAnnotationFromTag(ctx, tagId, annotationId)
        d.log(ctx, "RemoveAnnotation", start, err, fmt.Sprintf("tag=%d ann=%d", tagId, annotationId))
        return err
}</span>

func (d *dbLogger) GetTagAnnotation(ctx context.Context, conds ...interface{}) (*model.TagAnnotation, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetTagAnnotation(ctx, conds...)
        d.log(ctx, "GetAnnotation", start, err, result)
        return result, err
}</span>

func (d *dbLogger) GetTagAnnotations(ctx context.Context, tagId uint64) ([]model.TagAnnotation, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetTagAnnotations(ctx, tagId)
        d.log(ctx, "GetAnnotations", start, err, result)
        return result, err
}</span>

// TagImageType operations
func (d *dbLogger) CreateOrUpdateTagImageType(ctx context.Context, tit *model.TagImageType) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.CreateOrUpdateTagImageType(ctx, tit)
        d.log(ctx, "CreateUpdateImgType", start, err, tit)
        return err
}</span>

func (d *dbLogger) GetTagImageType(ctx context.Context, conds ...interface{}) (*model.TagImageType, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetTagImageType(ctx, conds...)
        d.log(ctx, "GetImgType", start, err, result)
        return result, err
}</span>

func (d *dbLogger) GetTagImageTypes(ctx context.Context, conds ...interface{}) (*[]model.TagImageType, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetTagImageTypes(ctx, conds...)
        d.log(ctx, "GetImgTypes", start, err, result)
        return result, err
}</span>

func (d *dbLogger) GetAllTagImageTypes(ctx context.Context) (*[]model.TagImageType, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetAllTagImageTypes(ctx)
        d.log(ctx, "GetAllImgTypes", start, err, result)
        return result, err
}</span>

// TagCustomCommand operations
func (d *dbLogger) CreateOrUpdateTagCustomCommand(ctx context.Context, command *model.TagCustomCommand) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.CreateOrUpdateTagCustomCommand(ctx, command)
        d.log(ctx, "CreateUpdateCmd", start, err, command)
        return err
}</span>

func (d *dbLogger) GetTagCustomCommand(ctx context.Context, conds ...interface{}) (*[]model.TagCustomCommand, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetTagCustomCommand(ctx, conds...)
        d.log(ctx, "GetCmd", start, err, result)
        return result, err
}</span>

func (d *dbLogger) GetAllTagCustomCommands(ctx context.Context) (*[]model.TagCustomCommand, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetAllTagCustomCommands(ctx)
        d.log(ctx, "GetAllCmds", start, err, result)
        return result, err
}</span>

// Tag operations
func (d *dbLogger) CreateOrUpdateTag(ctx context.Context, tag *model.Tag) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.CreateOrUpdateTag(ctx, tag)
        d.log(ctx, "CreateUpdateTag", start, err, tag)
        return err
}</span>

func (d *dbLogger) UpdateTag(ctx context.Context, tag *model.Tag) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.UpdateTag(ctx, tag)
        d.log(ctx, "UpdateTag", start, err, tag)
        return err
}</span>

func (d *dbLogger) GetTag(ctx context.Context, conds ...interface{}) (*model.Tag, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetTag(ctx, conds...)
        d.log(ctx, "GetTag", start, err, result)
        return result, err
}</span>

func (d *dbLogger) GetTagsWithoutChildren(ctx context.Context, conds ...interface{}) (*[]model.Tag, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetTagsWithoutChildren(ctx, conds...)
        d.log(ctx, "GetTagsNoChildren", start, err, result)
        return result, err
}</span>

func (d *dbLogger) GetTags(ctx context.Context, conds ...interface{}) (*[]model.Tag, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetTags(ctx, conds...)
        d.log(ctx, "GetTags", start, err, result)
        return result, err
}</span>

func (d *dbLogger) GetAllTags(ctx context.Context) (*[]model.Tag, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetAllTags(ctx)
        d.log(ctx, "GetAllTags", start, err, result)
        return result, err
}</span>

func (d *dbLogger) RemoveTagImageFromTag(ctx context.Context, tagId uint64, imageId uint64) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.RemoveTagImageFromTag(ctx, tagId, imageId)
        d.log(ctx, "RemoveTagImage", start, err, fmt.Sprintf("tag=%d img=%d", tagId, imageId))
        return err
}</span>

func (d *dbLogger) UpdateTagImage(ctx context.Context, image *model.TagImage) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.UpdateTagImage(ctx, image)
        d.log(ctx, "UpdateTagImage", start, err, image)
        return err
}</span>

func (d *dbLogger) GetTagsCount(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetTagsCount(ctx)
        d.log(ctx, "GetTagsCount", start, err, result)
        return result, err
}</span>

// Task operations
func (d *dbLogger) CreateTask(ctx context.Context, task *model.Task) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.CreateTask(ctx, task)
        d.log(ctx, "CreateTask", start, err, task)
        return err
}</span>

func (d *dbLogger) UpdateTask(ctx context.Context, task *model.Task) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.UpdateTask(ctx, task)
        d.log(ctx, "UpdateTask", start, err, task)
        return err
}</span>

func (d *dbLogger) RemoveTasks(ctx context.Context, conds ...interface{}) error <span class="cov0" title="0">{
        start := time.Now()
        err := d.db.RemoveTasks(ctx, conds...)
        d.log(ctx, "RemoveTasks", start, err, nil)
        return err
}</span>

func (d *dbLogger) TasksCount(ctx context.Context, query interface{}, conds ...interface{}) (int64, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.TasksCount(ctx, query, conds...)
        d.log(ctx, "TasksCount", start, err, result)
        return result, err
}</span>

func (d *dbLogger) GetTasks(ctx context.Context, offset int, limit int) (*[]model.Task, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := d.db.GetTasks(ctx, offset, limit)
        d.log(ctx, "GetTasks", start, err, result)
        return result, err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package db

import (
        "context"
        "my-collection/server/pkg/model"

        "github.com/go-errors/errors"
        "github.com/mattn/go-sqlite3"
        "gorm.io/gorm"
)

func (d *databaseImpl) CreateOrUpdateDirectory(ctx context.Context, directory *model.Directory) error <span class="cov8" title="1">{
        err := d.create(ctx, directory)

        if err != nil &amp;&amp; err.(*errors.Error).Err.(sqlite3.Error).Code == sqlite3.ErrConstraint </span><span class="cov8" title="1">{
                return d.update(ctx, directory)
        }</span>

        <span class="cov8" title="1">return err</span>
}

func (d *databaseImpl) UpdateDirectory(ctx context.Context, directory *model.Directory) error <span class="cov0" title="0">{
        return d.update(ctx, directory)
}</span>

func (d *databaseImpl) RemoveDirectory(ctx context.Context, path string) error <span class="cov8" title="1">{
        return d.delete(ctx, model.Directory{Path: path})
}</span>

func (d *databaseImpl) RemoveTagFromDirectory(ctx context.Context, direcotryPath string, tagId uint64) error <span class="cov0" title="0">{
        return d.deleteAssociation(ctx, model.Directory{Path: direcotryPath}, model.Tag{Id: tagId}, "Tags")
}</span>

func (d *databaseImpl) getDirectoryModel(ctx context.Context) *gorm.DB <span class="cov8" title="1">{
        tagsPreloading := func(db *gorm.DB) *gorm.DB </span><span class="cov8" title="1">{
                return db.Select("ID")
        }</span>

        <span class="cov8" title="1">return d.db.WithContext(ctx).Model(model.Directory{}).Preload("Tags", tagsPreloading)</span>
}

func (d *databaseImpl) GetDirectory(ctx context.Context, conds ...interface{}) (*model.Directory, error) <span class="cov8" title="1">{
        directory := &amp;model.Directory{}
        err := d.handleError(d.getDirectoryModel(ctx).First(directory, conds...).Error)
        return directory, err
}</span>

func (d *databaseImpl) GetDirectories(ctx context.Context, conds ...interface{}) (*[]model.Directory, error) <span class="cov8" title="1">{
        var directories []model.Directory
        err := d.handleError(d.getDirectoryModel(ctx).Find(&amp;directories, conds...).Error)
        return &amp;directories, err
}</span>

func (d *databaseImpl) GetAllDirectories(ctx context.Context) (*[]model.Directory, error) <span class="cov8" title="1">{
        return d.GetDirectories(ctx)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package db

import (
        "context"
        "my-collection/server/pkg/model"

        "github.com/go-errors/errors"
        "github.com/mattn/go-sqlite3"
        "gorm.io/gorm"
)

func (d *databaseImpl) CreateOrUpdateItem(ctx context.Context, item *model.Item) error <span class="cov8" title="1">{
        if item.Id == 0 &amp;&amp; (item.Title == "" || item.Origin == "") </span><span class="cov0" title="0">{
                return errors.Errorf("invalid item, missing ('id') or ('title' and 'origin') %v", item)
        }</span>

        <span class="cov8" title="1">err := d.create(ctx, item)

        if err != nil &amp;&amp; err.(*errors.Error).Err.(sqlite3.Error).Code == sqlite3.ErrConstraint </span><span class="cov8" title="1">{
                if item.Id != 0 </span><span class="cov8" title="1">{
                        return d.update(ctx, item)
                }</span>

                <span class="cov0" title="0">existing, err := d.GetItem(ctx, "title = ? and origin = ?", item.Title, item.Origin)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">item.Id = existing.Id
                return d.update(ctx, item)</span>
        }

        <span class="cov8" title="1">return err</span>
}

func (d *databaseImpl) UpdateItem(ctx context.Context, item *model.Item) error <span class="cov8" title="1">{
        return d.update(ctx, item)
}</span>

func (d *databaseImpl) RemoveItem(ctx context.Context, itemId uint64) error <span class="cov8" title="1">{
        return d.deleteWithAssociations(ctx, model.Item{Id: itemId})
}</span>

func (d *databaseImpl) RemoveTagFromItem(ctx context.Context, itemId uint64, tagId uint64) error <span class="cov8" title="1">{
        return d.deleteAssociation(ctx, model.Item{Id: itemId}, model.Tag{Id: tagId}, "Tags")
}</span>

func (d *databaseImpl) getItemModel(ctx context.Context, includeTagIdsOnly bool) *gorm.DB <span class="cov8" title="1">{
        tagsPreloading := func(db *gorm.DB) *gorm.DB </span><span class="cov8" title="1">{
                if includeTagIdsOnly </span><span class="cov0" title="0">{
                        return db.Select("ID", "ParentID")
                }</span> else<span class="cov8" title="1"> {
                        return db.Preload("Images")
                }</span>
        }

        <span class="cov8" title="1">subItemsPreloading := func(db *gorm.DB) *gorm.DB </span><span class="cov8" title="1">{
                return db.Preload("Covers").Preload("Tags", tagsPreloading)
        }</span>

        <span class="cov8" title="1">highlightsPreloading := func(db *gorm.DB) *gorm.DB </span><span class="cov8" title="1">{
                return db.Preload("Covers").Preload("Tags", tagsPreloading)
        }</span>

        <span class="cov8" title="1">return d.db.WithContext(ctx).Model(&amp;model.Item{}).
                Preload("Tags", tagsPreloading).
                Preload("Covers").
                Preload("SubItems", subItemsPreloading).
                Preload("Highlights", highlightsPreloading)</span>
}

func (d *databaseImpl) GetItem(ctx context.Context, conds ...interface{}) (*model.Item, error) <span class="cov8" title="1">{
        item := &amp;model.Item{}
        err := d.handleError(d.getItemModel(ctx, false).First(item, conds...).Error)
        return item, err
}</span>

func (d *databaseImpl) GetItems(ctx context.Context, conds ...interface{}) (*[]model.Item, error) <span class="cov8" title="1">{
        var items []model.Item
        err := d.handleError(d.getItemModel(ctx, false).Find(&amp;items, conds...).Error)
        return &amp;items, err
}</span>

func (d *databaseImpl) GetAllItems(ctx context.Context) (*[]model.Item, error) <span class="cov8" title="1">{
        return d.GetItems(ctx)
}</span>

func (d *databaseImpl) GetItemsCount(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        var count int64
        err := d.handleError(d.db.Model(&amp;model.Item{}).WithContext(ctx).Count(&amp;count).Error)
        return count, err
}</span>

func (d *databaseImpl) GetTotalDurationSeconds(ctx context.Context) (float64, error) <span class="cov0" title="0">{
        var result struct {
                Total float64
        }

        err := d.handleError(d.db.Model(&amp;model.Item{}).WithContext(ctx).Select("sum(duration_seconds) as total").Scan(&amp;result).Error)
        return result.Total, err
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package db

import (
        "context"
        "my-collection/server/pkg/model"
)

func (d *databaseImpl) CreateTagAnnotation(ctx context.Context, tagAnnotation *model.TagAnnotation) error <span class="cov8" title="1">{
        return d.create(ctx, tagAnnotation)
}</span>

func (d *databaseImpl) RemoveTag(ctx context.Context, tagId uint64) error <span class="cov8" title="1">{
        return d.delete(ctx, model.Tag{Id: tagId})
}</span>

func (d *databaseImpl) RemoveTagAnnotationFromTag(ctx context.Context, tagId uint64, annotationId uint64) error <span class="cov8" title="1">{
        return d.deleteAssociation(ctx, model.Tag{Id: tagId}, model.TagAnnotation{Id: annotationId}, "Annotations")
}</span>

func (d *databaseImpl) GetTagAnnotation(ctx context.Context, conds ...interface{}) (*model.TagAnnotation, error) <span class="cov8" title="1">{
        tagAnnotation := &amp;model.TagAnnotation{}
        err := d.handleError(d.db.WithContext(ctx).Model(tagAnnotation).First(tagAnnotation, conds...).Error)
        return tagAnnotation, err
}</span>

func (d *databaseImpl) GetTagAnnotations(ctx context.Context, tagId uint64) ([]model.TagAnnotation, error) <span class="cov8" title="1">{
        var annotations []model.TagAnnotation
        err := d.handleError(d.db.WithContext(ctx).Model(&amp;model.Tag{Id: tagId}).Association("Annotations").Find(&amp;annotations))
        return annotations, err
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package db

import (
        "context"
        "my-collection/server/pkg/model"

        "github.com/go-errors/errors"
        "github.com/mattn/go-sqlite3"
)

func (d *databaseImpl) CreateOrUpdateTagImageType(ctx context.Context, tit *model.TagImageType) error <span class="cov0" title="0">{
        if tit.Id == 0 &amp;&amp; tit.Nickname == "" </span><span class="cov0" title="0">{
                return errors.Errorf("invalid tag image type, missing ('id') or ('title') %v", tit)
        }</span>

        <span class="cov0" title="0">err := d.create(ctx, tit)

        if err != nil &amp;&amp; err.(*errors.Error).Err.(sqlite3.Error).Code == sqlite3.ErrConstraint </span><span class="cov0" title="0">{
                if tit.Id != 0 </span><span class="cov0" title="0">{
                        return d.update(ctx, tit)
                }</span>

                <span class="cov0" title="0">existing, err := d.GetItem(ctx, "nickname = ?", tit.Nickname)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">tit.Id = existing.Id
                return d.update(ctx, tit)</span>
        }

        <span class="cov0" title="0">return err</span>
}

func (d *databaseImpl) GetTagImageType(ctx context.Context, conds ...interface{}) (*model.TagImageType, error) <span class="cov0" title="0">{
        tit := &amp;model.TagImageType{}
        err := d.handleError(d.db.WithContext(ctx).Model(tit).First(tit, conds...).Error)
        return tit, err
}</span>

func (d *databaseImpl) GetTagImageTypes(ctx context.Context, conds ...interface{}) (*[]model.TagImageType, error) <span class="cov8" title="1">{
        var tits []model.TagImageType
        err := d.handleError(d.db.WithContext(ctx).Model(model.TagImageType{}).Find(&amp;tits, conds...).Error)
        return &amp;tits, err
}</span>

func (d *databaseImpl) GetAllTagImageTypes(ctx context.Context) (*[]model.TagImageType, error) <span class="cov8" title="1">{
        return d.GetTagImageTypes(ctx)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package db

import (
        "context"
        "my-collection/server/pkg/model"

        "github.com/go-errors/errors"
        "github.com/mattn/go-sqlite3"
)

func (d *databaseImpl) CreateOrUpdateTagCustomCommand(ctx context.Context, command *model.TagCustomCommand) error <span class="cov0" title="0">{
        if command.Id == 0 &amp;&amp; command.Title == "" </span><span class="cov0" title="0">{
                return errors.Errorf("invalid command, missing ('id') or ('title') %v", command)
        }</span>

        <span class="cov0" title="0">err := d.create(ctx, command)

        if err != nil &amp;&amp; err.(*errors.Error).Err.(sqlite3.Error).Code == sqlite3.ErrConstraint </span><span class="cov0" title="0">{
                if command.Id != 0 </span><span class="cov0" title="0">{
                        return d.update(ctx, command)
                }</span>

                <span class="cov0" title="0">existing, err := d.GetItem(ctx, "title = ?", command.Title)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">command.Id = existing.Id
                return d.update(ctx, command)</span>
        }

        <span class="cov0" title="0">return err</span>
}

func (d *databaseImpl) GetTagCustomCommand(ctx context.Context, conds ...interface{}) (*[]model.TagCustomCommand, error) <span class="cov8" title="1">{
        var commands []model.TagCustomCommand
        err := d.handleError(d.db.WithContext(ctx).Model(model.TagCustomCommand{}).Find(&amp;commands, conds...).Error)
        return &amp;commands, err
}</span>

func (d *databaseImpl) GetAllTagCustomCommands(ctx context.Context) (*[]model.TagCustomCommand, error) <span class="cov8" title="1">{
        return d.GetTagCustomCommand(ctx)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package db

import (
        "context"
        "my-collection/server/pkg/model"

        "github.com/go-errors/errors"
        "github.com/mattn/go-sqlite3"
        "gorm.io/gorm"
)

func (d *databaseImpl) CreateOrUpdateTag(ctx context.Context, tag *model.Tag) error <span class="cov8" title="1">{
        if tag.Id == 0 &amp;&amp; tag.Title == "" </span><span class="cov0" title="0">{
                return errors.Errorf("Invalid tag, missing id or title %v", tag)
        }</span>

        <span class="cov8" title="1">err := d.create(ctx, tag)

        if err != nil &amp;&amp; err.(*errors.Error).Err.(sqlite3.Error).Code == sqlite3.ErrConstraint </span><span class="cov8" title="1">{
                if tag.Id != 0 </span><span class="cov8" title="1">{
                        return d.update(ctx, tag)
                }</span>

                <span class="cov0" title="0">existing, err := d.GetTag(ctx, "title = ? and parent_id = ?", tag.Title, tag.ParentID)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">tag.Id = existing.Id
                return d.update(ctx, tag)</span>
        }

        <span class="cov8" title="1">return err</span>
}

func (d *databaseImpl) UpdateTag(ctx context.Context, tag *model.Tag) error <span class="cov8" title="1">{
        return d.update(ctx, tag)
}</span>

func (d *databaseImpl) getTagModel(ctx context.Context, withChildren bool) *gorm.DB <span class="cov8" title="1">{
        itemsPreloading := func(db *gorm.DB) *gorm.DB </span><span class="cov8" title="1">{
                return db.Select("ID")
        }</span>

        <span class="cov8" title="1">annotationsPreloading := func(db *gorm.DB) *gorm.DB </span><span class="cov8" title="1">{
                return db.Select("ID")
        }</span>

        <span class="cov8" title="1">model := d.db.WithContext(ctx).Model(model.Tag{}).
                Preload("Images").
                Preload("Items", itemsPreloading).
                Preload("Annotations", annotationsPreloading)

        if withChildren </span><span class="cov8" title="1">{
                model = model.Preload("Children")
        }</span>

        <span class="cov8" title="1">return model</span>
}

func (d *databaseImpl) GetTag(ctx context.Context, conds ...interface{}) (*model.Tag, error) <span class="cov8" title="1">{
        tag := &amp;model.Tag{}
        err := d.handleError(d.getTagModel(ctx, true).First(tag, conds...).Error)
        return tag, err
}</span>

func (d *databaseImpl) GetTagsWithoutChildren(ctx context.Context, conds ...interface{}) (*[]model.Tag, error) <span class="cov8" title="1">{
        var tags []model.Tag
        err := d.handleError(d.getTagModel(ctx, false).Find(&amp;tags, conds...).Error)
        return &amp;tags, err
}</span>

func (d *databaseImpl) GetTags(ctx context.Context, conds ...interface{}) (*[]model.Tag, error) <span class="cov8" title="1">{
        var tags []model.Tag
        err := d.handleError(d.getTagModel(ctx, true).Find(&amp;tags, conds...).Error)
        return &amp;tags, err
}</span>

func (d *databaseImpl) GetAllTags(ctx context.Context) (*[]model.Tag, error) <span class="cov8" title="1">{
        return d.GetTags(ctx)
}</span>

func (d *databaseImpl) RemoveTagImageFromTag(ctx context.Context, tagId uint64, imageId uint64) error <span class="cov0" title="0">{
        return d.deleteAssociation(ctx, model.Tag{Id: tagId}, model.TagImage{Id: imageId}, "Images")
}</span>

func (d *databaseImpl) UpdateTagImage(ctx context.Context, image *model.TagImage) error <span class="cov0" title="0">{
        return d.update(ctx, image)
}</span>

func (d *databaseImpl) GetTagsCount(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        var count int64
        err := d.handleError(d.db.WithContext(ctx).Model(&amp;model.Tag{}).Count(&amp;count).Error)
        return count, err
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package db

import (
        "context"
        "my-collection/server/pkg/model"
)

func (d *databaseImpl) CreateTask(ctx context.Context, task *model.Task) error <span class="cov0" title="0">{
        return d.create(ctx, task)
}</span>

func (d *databaseImpl) UpdateTask(ctx context.Context, task *model.Task) error <span class="cov0" title="0">{
        return d.update(ctx, task)
}</span>

func (d *databaseImpl) RemoveTasks(ctx context.Context, conds ...interface{}) error <span class="cov0" title="0">{
        return d.delete(ctx, model.Task{}, conds...)
}</span>

func (d *databaseImpl) TasksCount(ctx context.Context, query interface{}, conds ...interface{}) (int64, error) <span class="cov0" title="0">{
        var count int64
        err := d.handleError(d.db.WithContext(ctx).Model(model.Task{}).Where(query, conds...).Count(&amp;count).Error)
        return count, err
}</span>

func (d *databaseImpl) GetTasks(ctx context.Context, offset int, limit int) (*[]model.Task, error) <span class="cov0" title="0">{
        var tasks []model.Task
        err := d.handleError(d.db.WithContext(ctx).Model(model.Task{}).Offset(offset).Limit(limit).Find(&amp;tasks).Error)
        return &amp;tasks, err
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package directorytree

import (
        "path/filepath"
)

func Compare(fs *DirectoryNode, db *DirectoryNode) *Diff <span class="cov8" title="1">{
        rawChanges := newIndexedChanges()
        compareDirectory(fs, db, rawChanges)
        diff := detectMoves(rawChanges)
        rawChanges.addToDiff(diff)
        removeExcluded(db, diff)
        return diff
}</span>

func compareDirectory(fs *DirectoryNode, db *DirectoryNode, changes *indexedChanges) <span class="cov8" title="1">{
        bothDirs, fsDirsOnly, dbDirsOnly := compareSubDirectories(fs, db)
        createDirsChanges(fsDirsOnly, dbDirsOnly, changes)

        fsFilesOnly, dbFilesOnly := compareFiles(fs, db)
        createFilesChanges(fsFilesOnly, dbFilesOnly, changes)

        for _, dir := range bothDirs </span><span class="cov8" title="1">{
                compareDirectory(dir[0], dir[1], changes)
        }</span>

        <span class="cov8" title="1">for _, dir := range fsDirsOnly </span><span class="cov8" title="1">{
                compareDirectory(dir, nil, changes)
        }</span>

        <span class="cov8" title="1">for _, dir := range dbDirsOnly </span><span class="cov8" title="1">{
                compareDirectory(nil, dir, changes)
        }</span>
}

func createDirsChanges(fsDirsOnly []*DirectoryNode, dbDirsOnly []*DirectoryNode, changes *indexedChanges) <span class="cov8" title="1">{
        for _, dir := range fsDirsOnly </span><span class="cov8" title="1">{
                changes.dirAdded(dir.getPath())
        }</span>

        <span class="cov8" title="1">for _, dir := range dbDirsOnly </span><span class="cov8" title="1">{
                changes.dirRemoved(dir.getPath())
        }</span>
}

func createFilesChanges(fsFilesOnly []*FileNode, dbFilesOnly []*FileNode, changes *indexedChanges) <span class="cov8" title="1">{
        for _, file := range fsFilesOnly </span><span class="cov8" title="1">{
                changes.fileAdded(file.getPath())
        }</span>

        <span class="cov8" title="1">for _, file := range dbFilesOnly </span><span class="cov8" title="1">{
                changes.fileRemoved(file.getPath())
        }</span>
}

func compareSubDirectories(fs *DirectoryNode, db *DirectoryNode) ([][]*DirectoryNode, []*DirectoryNode, []*DirectoryNode) <span class="cov8" title="1">{
        both := make([][]*DirectoryNode, 0)
        fsOnly := make([]*DirectoryNode, 0)
        dbOnly := make([]*DirectoryNode, 0)
        if db == nil </span><span class="cov8" title="1">{
                return both, fs.Children, dbOnly
        }</span>

        <span class="cov8" title="1">if fs == nil </span><span class="cov8" title="1">{
                return both, fsOnly, db.Children
        }</span>

<span class="cov8" title="1">outFs:
        for _, fsDir := range fs.Children </span><span class="cov8" title="1">{
                for _, dbDir := range db.Children </span><span class="cov8" title="1">{
                        if fsDir.Title == dbDir.Title </span><span class="cov8" title="1">{
                                both = append(both, []*DirectoryNode{fsDir, dbDir})
                                continue outFs</span>
                        }
                }

                <span class="cov8" title="1">fsOnly = append(fsOnly, fsDir)</span>
        }

<span class="cov8" title="1">outDb:
        for _, dbDir := range db.Children </span><span class="cov8" title="1">{
                for _, fsDir := range fs.Children </span><span class="cov8" title="1">{
                        if dbDir.Title == fsDir.Title </span><span class="cov8" title="1">{
                                continue outDb</span>
                        }
                }

                <span class="cov8" title="1">dbOnly = append(dbOnly, dbDir)</span>
        }

        <span class="cov8" title="1">return both, fsOnly, dbOnly</span>
}

func compareFiles(fs *DirectoryNode, db *DirectoryNode) ([]*FileNode, []*FileNode) <span class="cov8" title="1">{
        fsOnly := make([]*FileNode, 0)
        dbOnly := make([]*FileNode, 0)
        if db == nil </span><span class="cov8" title="1">{
                return fs.Files, dbOnly
        }</span>
        <span class="cov8" title="1">if fs == nil </span><span class="cov8" title="1">{
                return fsOnly, db.Files
        }</span>

<span class="cov8" title="1">outFs:
        for _, fsFile := range fs.Files </span><span class="cov8" title="1">{
                for _, dbFile := range db.Files </span><span class="cov8" title="1">{
                        if fsFile.Title == dbFile.Title </span><span class="cov8" title="1">{
                                continue outFs</span>
                        }
                }

                <span class="cov8" title="1">fsOnly = append(fsOnly, fsFile)</span>
        }

<span class="cov8" title="1">outDb:
        for _, dbFile := range db.Files </span><span class="cov8" title="1">{
                for _, fsFile := range fs.Files </span><span class="cov8" title="1">{
                        if dbFile.Title == fsFile.Title </span><span class="cov8" title="1">{
                                continue outDb</span>
                        }
                }

                <span class="cov8" title="1">dbOnly = append(dbOnly, dbFile)</span>
        }

        <span class="cov8" title="1">return fsOnly, dbOnly</span>
}

func detectMoves(rawChanges *indexedChanges) *Diff <span class="cov8" title="1">{
        diff := newDiff()
        changed := false

        for filename, l := range rawChanges.removedDirs </span><span class="cov8" title="1">{
                for _, p := range l </span><span class="cov8" title="1">{
                        changed = detectDirectoryMove(diff, rawChanges, p)
                        if changed </span><span class="cov8" title="1">{
                                rawChanges.removedDirs[filename] = make([]string, 0)
                        }</span>
                }
        }

        <span class="cov8" title="1">for filename, l := range rawChanges.removedFiles </span><span class="cov8" title="1">{
                for _, p := range l </span><span class="cov8" title="1">{
                        changed = detectFileMove(diff, rawChanges, p)
                        if changed </span><span class="cov8" title="1">{
                                rawChanges.removedFiles[filename] = make([]string, 0)
                        }</span>
                }
        }

        <span class="cov8" title="1">return diff</span>
}

func detectDirectoryMove(diff *Diff, rawChanges *indexedChanges, path string) bool <span class="cov8" title="1">{
        filename := filepath.Base(path)
        l, ok := rawChanges.addedDirs[filename]
        if !ok || len(l) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">rawChanges.addedDirs[filename] = make([]string, 0)
        diff.MovedDirectories = append(diff.MovedDirectories, Change{Path1: path, Path2: l[0], ChangeType: DIRECTORY_MOVED})
        return true</span>
}

func detectFileMove(diff *Diff, rawChanges *indexedChanges, path string) bool <span class="cov8" title="1">{
        filename := filepath.Base(path)
        l, ok := rawChanges.addedFiles[filename]
        if !ok || len(l) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">rawChanges.addedFiles[filename] = make([]string, 0)
        diff.MovedFiles = append(diff.MovedFiles, Change{Path1: path, Path2: l[0], ChangeType: FILE_MOVED})
        return true</span>
}

func removeExcluded(db *DirectoryNode, diff *Diff) <span class="cov8" title="1">{
        diff.AddedDirectories = removeExcludedFromChanges(db, diff.AddedDirectories)
        diff.AddedFiles = removeExcludedFromChanges(db, diff.AddedFiles)
}</span>

func removeExcludedFromChanges(db *DirectoryNode, changes []Change) []Change <span class="cov8" title="1">{
        counter := 0
        for </span><span class="cov8" title="1">{
                if counter &gt;= len(changes) </span><span class="cov8" title="1">{
                        return changes
                }</span>

                <span class="cov8" title="1">change := changes[counter]
                if db.isExcluded(change.Path1) </span><span class="cov8" title="1">{
                        changes = append(changes[:counter], changes[counter+1:]...)
                        continue</span>
                }

                <span class="cov8" title="1">counter = counter + 1</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package directorytree

import (
        "fmt"
        "path/filepath"
        "strings"
)

func newDiff() *Diff <span class="cov8" title="1">{
        return &amp;Diff{
                AddedDirectories:   make([]Change, 0),
                RemovedDirectories: make([]Change, 0),
                AddedFiles:         make([]Change, 0),
                RemovedFiles:       make([]Change, 0),
                MovedDirectories:   make([]Change, 0),
                MovedFiles:         make([]Change, 0),
        }
}</span>

type Diff struct {
        AddedDirectories   []Change
        RemovedDirectories []Change
        AddedFiles         []Change
        RemovedFiles       []Change
        MovedDirectories   []Change
        MovedFiles         []Change
}

func (s *Diff) HasChanges() bool <span class="cov8" title="1">{
        return len(s.AddedDirectories) &gt; 0 ||
                len(s.RemovedDirectories) &gt; 0 ||
                len(s.AddedFiles) &gt; 0 ||
                len(s.RemovedFiles) &gt; 0 ||
                len(s.MovedDirectories) &gt; 0 ||
                len(s.MovedFiles) &gt; 0
}</span>

func (d *Diff) ChangesTotal() int <span class="cov0" title="0">{
        return len(d.AddedDirectories) +
                len(d.RemovedDirectories) +
                len(d.AddedFiles) +
                len(d.RemovedFiles) +
                len(d.MovedDirectories) +
                len(d.MovedFiles)
}</span>

type ChangeType int

const (
        DIRECTORY_ADDED = iota
        DIRECTORY_REMOVED
        DIRECTORY_MOVED
        FILE_ADDED
        FILE_REMOVED
        FILE_MOVED
)

type Change struct {
        Path1      string
        Path2      string
        ChangeType ChangeType
}

func (c *Change) String() string <span class="cov8" title="1">{
        switch c.ChangeType </span>{
        case DIRECTORY_ADDED:<span class="cov8" title="1">
                return fmt.Sprintf("+ %s", c.Path1)</span>
        case DIRECTORY_REMOVED:<span class="cov8" title="1">
                return fmt.Sprintf("- %s", c.Path1)</span>
        case DIRECTORY_MOVED:<span class="cov8" title="1">
                return fmt.Sprintf("%s -&gt; %s", c.Path1, c.Path2)</span>
        case FILE_ADDED:<span class="cov8" title="1">
                return fmt.Sprintf("+ %s", c.Path1)</span>
        case FILE_REMOVED:<span class="cov8" title="1">
                return fmt.Sprintf("- %s", c.Path1)</span>
        case FILE_MOVED:<span class="cov8" title="1">
                return fmt.Sprintf("%s -&gt; %s", c.Path1, c.Path2)</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

func (d *Diff) String() string <span class="cov0" title="0">{
        result := make([]string, 0)
        result = append(result, d.ChangesToString(d.AddedDirectories)...)
        result = append(result, d.ChangesToString(d.RemovedDirectories)...)
        result = append(result, d.ChangesToString(d.AddedFiles)...)
        result = append(result, d.ChangesToString(d.RemovedFiles)...)
        result = append(result, d.ChangesToString(d.MovedDirectories)...)
        result = append(result, d.ChangesToString(d.MovedFiles)...)
        return strings.Join(result, "\n")
}</span>

func (d *Diff) ChangesToString(changes []Change) []string <span class="cov8" title="1">{
        strs := make([]string, len(changes))
        for i, v := range changes </span><span class="cov8" title="1">{
                strs[i] = v.String()
        }</span>

        <span class="cov8" title="1">return strs</span>
}

func newIndexedChanges() *indexedChanges <span class="cov8" title="1">{
        return &amp;indexedChanges{
                addedDirs:    make(map[string][]string),
                addedFiles:   make(map[string][]string),
                removedDirs:  make(map[string][]string),
                removedFiles: make(map[string][]string),
        }
}</span>

type indexedChanges struct {
        addedDirs    map[string][]string
        addedFiles   map[string][]string
        removedDirs  map[string][]string
        removedFiles map[string][]string
}

func (i *indexedChanges) dirAdded(path string) <span class="cov8" title="1">{
        filename := filepath.Base(path)
        i.addedDirs[filename] = append(i.addedDirs[filename], path)
}</span>

func (i *indexedChanges) dirRemoved(path string) <span class="cov8" title="1">{
        filename := filepath.Base(path)
        i.removedDirs[filename] = append(i.removedDirs[filename], path)
}</span>

func (i *indexedChanges) fileAdded(path string) <span class="cov8" title="1">{
        filename := filepath.Base(path)
        i.addedFiles[filename] = append(i.addedFiles[filename], path)
}</span>

func (i *indexedChanges) fileRemoved(path string) <span class="cov8" title="1">{
        filename := filepath.Base(path)
        i.removedFiles[filename] = append(i.removedFiles[filename], path)
}</span>

func (i *indexedChanges) addToDiff(diff *Diff) <span class="cov8" title="1">{
        diff.AddedDirectories = append(diff.AddedDirectories, i.mapToChanges(DIRECTORY_ADDED, i.addedDirs)...)
        diff.RemovedDirectories = append(diff.RemovedDirectories, i.mapToChanges(DIRECTORY_REMOVED, i.removedDirs)...)
        diff.AddedFiles = append(diff.AddedFiles, i.mapToChanges(FILE_ADDED, i.addedFiles)...)
        diff.RemovedFiles = append(diff.RemovedFiles, i.mapToChanges(FILE_REMOVED, i.removedFiles)...)
}</span>

func (i *indexedChanges) mapToChanges(ct ChangeType, m map[string][]string) []Change <span class="cov8" title="1">{
        changes := make([]Change, 0)
        for _, l := range m </span><span class="cov8" title="1">{
                for _, f := range l </span><span class="cov8" title="1">{
                        changes = append(changes, Change{ChangeType: ct, Path1: f})
                }</span>
        }

        <span class="cov8" title="1">return changes</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package directorytree

import (
        "fmt"
        "strings"
)

type Stale struct {
        Dirs  []string
        Files []string
}

func (s *Stale) HasChanges() bool <span class="cov8" title="1">{
        return len(s.Dirs) &gt; 0 || len(s.Files) &gt; 0
}</span>

func (s *Stale) String() string <span class="cov0" title="0">{
        dirs := fmt.Sprintf("dirs: %s", strings.Join(s.Dirs, "\n\t"))
        files := fmt.Sprintf("files: %s", strings.Join(s.Files, "\n\t"))
        return fmt.Sprintf("%s\n%s", dirs, files)
}</span>

func FindStales(db *DirectoryNode) *Stale <span class="cov8" title="1">{
        result := Stale{}
        findStale(db, &amp;result)
        return &amp;result
}</span>

func findStale(node *DirectoryNode, result *Stale) <span class="cov8" title="1">{
        if node.Excluded </span><span class="cov8" title="1">{
                addToStale(node, result)
        }</span> else<span class="cov8" title="1"> {
                for _, child := range node.Children </span><span class="cov8" title="1">{
                        findStale(child, result)
                }</span>
        }
}

func addToStale(node *DirectoryNode, result *Stale) <span class="cov8" title="1">{
        if node.Parent != nil &amp;&amp; node.getRoot().isExcluded(node.Parent.getPath()) </span><span class="cov0" title="0">{
                result.Dirs = append(result.Dirs, node.getPath())
        }</span>

        <span class="cov8" title="1">for _, file := range node.Files </span><span class="cov8" title="1">{
                result.Files = append(result.Files, file.getPath())
        }</span>

        <span class="cov8" title="1">for _, child := range node.Children </span><span class="cov0" title="0">{
                addToStale(child, result)
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package directorytree

import (
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"

        "github.com/op/go-logging"
)

var logger = logging.MustGetLogger("tree")

type DirectoryNode struct {
        Parent   *DirectoryNode
        Children []*DirectoryNode
        Files    []*FileNode
        Title    string
        Excluded bool
}

type FileNode struct {
        Parent *DirectoryNode
        Title  string
}

func createFileNode(parent *DirectoryNode, title string) *FileNode <span class="cov8" title="1">{
        return &amp;FileNode{
                Parent: parent,
                Title:  title,
        }
}</span>

func createDirectoryNode(parent *DirectoryNode, title string) *DirectoryNode <span class="cov8" title="1">{
        return &amp;DirectoryNode{
                Parent:   parent,
                Title:    title,
                Children: make([]*DirectoryNode, 0),
                Files:    make([]*FileNode, 0),
        }
}</span>

func (dn *DirectoryNode) getPath() string <span class="cov8" title="1">{
        if dn.Parent == nil </span><span class="cov8" title="1">{
                return dn.Title
        }</span> else<span class="cov8" title="1"> {
                return filepath.Join(dn.Parent.getPath(), dn.Title)
        }</span>
}

func (dn *DirectoryNode) getRoot() *DirectoryNode <span class="cov8" title="1">{
        cur := dn
        for cur.Parent != nil </span><span class="cov8" title="1">{
                cur = cur.Parent
        }</span>

        <span class="cov8" title="1">return cur</span>
}

func (fn *FileNode) getPath() string <span class="cov8" title="1">{
        if fn.Parent == nil </span><span class="cov0" title="0">{
                return fn.Title
        }</span> else<span class="cov8" title="1"> {
                return filepath.Join(fn.Parent.getPath(), fn.Title)
        }</span>
}

func (dn *DirectoryNode) isExcluded(path string) bool <span class="cov8" title="1">{
        if path == "" || dn.Excluded </span><span class="cov8" title="1">{
                return dn.Excluded
        }</span>

        <span class="cov8" title="1">parts := strings.SplitN(path, string(os.PathSeparator), 2)
        firstDir := parts[0]
        remainingDirs := ""
        if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                remainingDirs = parts[1]
        }</span>

        <span class="cov8" title="1">for _, child := range dn.Children </span><span class="cov8" title="1">{
                if child.Title == firstDir </span><span class="cov8" title="1">{
                        return child.isExcluded(remainingDirs)
                }</span>
        }

        <span class="cov8" title="1">if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return dn.Excluded</span>
}

func (dn *DirectoryNode) String(depth int) string <span class="cov0" title="0">{
        var result strings.Builder
        result.WriteString(fmt.Sprintf("%s%s", strings.Repeat("  ", depth), dn.Title))
        result.WriteByte('\n')

        sort.SliceStable(dn.Files, func(i, j int) bool </span><span class="cov0" title="0">{ return dn.Files[i].Title &lt; dn.Files[j].Title }</span>)
        <span class="cov0" title="0">for _, file := range dn.Files </span><span class="cov0" title="0">{
                result.WriteString(file.String(depth + 1))
                result.WriteByte('\n')
        }</span>

        <span class="cov0" title="0">sort.SliceStable(dn.Children, func(i, j int) bool </span><span class="cov0" title="0">{ return dn.Children[i].Title &lt; dn.Children[j].Title }</span>)
        <span class="cov0" title="0">for _, child := range dn.Children </span><span class="cov0" title="0">{
                result.WriteString(child.String(depth + 1))
                result.WriteByte('\n')
        }</span>

        <span class="cov0" title="0">return result.String()</span>
}

func (fn *FileNode) String(depth int) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%s", strings.Repeat("  ", depth), fn.Title)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package directorytree

import (
        "context"
        "my-collection/server/pkg/bl/directories"
        "my-collection/server/pkg/model"
        "os"
        "strings"
)

func BuildFromDb(ctx context.Context, dr model.DirectoryReader, dig model.DirectoryItemsGetter) (*DirectoryNode, error) <span class="cov8" title="1">{
        dirs, err := dr.GetAllDirectories(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">root := createDirectoryNode(nil, "")
        for _, dir := range *dirs </span><span class="cov8" title="1">{
                path := dir.Path
                if path == model.ROOT_DIRECTORY_PATH </span><span class="cov8" title="1">{
                        path = ""
                }</span>

                <span class="cov8" title="1">child := root.getOrCreateChild(path)
                child.Excluded = directories.IsExcluded(&amp;dir)

                if err := child.readFilesFromDb(ctx, dig); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Error reading files from db %s", err)
                }</span>
        }

        <span class="cov8" title="1">return root, nil</span>
}

func (dn *DirectoryNode) getOrCreateChild(path string) *DirectoryNode <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                return dn
        }</span>

        <span class="cov8" title="1">parts := strings.SplitN(path, string(os.PathSeparator), 2)
        firstDir := parts[0]
        remainingDirs := ""
        if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                remainingDirs = parts[1]
        }</span>

        <span class="cov8" title="1">for _, child := range dn.Children </span><span class="cov8" title="1">{
                if child.Title == firstDir </span><span class="cov8" title="1">{
                        return child.getOrCreateChild(remainingDirs)
                }</span>
        }

        <span class="cov8" title="1">child := createDirectoryNode(dn, firstDir)
        dn.Children = append(dn.Children, child)
        return child.getOrCreateChild(remainingDirs)</span>
}

func (dn *DirectoryNode) readFilesFromDb(ctx context.Context, dig model.DirectoryItemsGetter) error <span class="cov8" title="1">{
        items, err := dig.GetBelongingItems(ctx, dn.getPath())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, item := range *items </span><span class="cov8" title="1">{
                dn.Files = append(dn.Files, createFileNode(dn, item.Title))
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package directorytree

import (
        "os"
        "path/filepath"
        "strings"
)

type FilesFilter interface {
        Filter(path string) bool
}

func BuildFromPath(path string, filter FilesFilter) (*DirectoryNode, error) <span class="cov8" title="1">{
        root, err := buildFromDir(nil, path, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return root, nil</span>
}

func buildFromDir(parent *DirectoryNode, path string, filter FilesFilter) (*DirectoryNode, error) <span class="cov8" title="1">{
        files, err := os.ReadDir(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">node := createDirectoryNode(parent, filepath.Base(path))
        if parent == nil </span><span class="cov8" title="1">{
                node.Title = ""
        }</span>

        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                if strings.HasPrefix(file.Name(), ".") </span><span class="cov0" title="0">{
                        // ignore hidden files and dirs
                        continue</span>
                }

                <span class="cov8" title="1">if file.IsDir() </span><span class="cov8" title="1">{
                        child, err := buildFromDir(node, filepath.Join(path, file.Name()), filter)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">node.Children = append(node.Children, child)</span>
                } else<span class="cov8" title="1"> if filter.Filter(filepath.Join(path, file.Name())) </span><span class="cov8" title="1">{
                        node.Files = append(node.Files, createFileNode(node, file.Name()))
                }</span>
        }

        <span class="cov8" title="1">return node, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package fssync

import (
        "context"
        "fmt"
        "my-collection/server/pkg/bl/directories"
        "my-collection/server/pkg/model"
)

func NewCachedDig(ctx context.Context, tr model.TagReader, ir model.ItemReader) (*CachedDig, error) <span class="cov8" title="1">{
        tags, err := tr.GetAllTags(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tagsMap := make(map[string]model.Tag)
        for _, tag := range *tags </span><span class="cov8" title="1">{
                if tag.ParentID == nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if *tag.ParentID == directories.GetDirectoriesTagId() </span><span class="cov8" title="1">{
                        tagsMap[tag.Title] = tag
                }</span>
        }

        <span class="cov8" title="1">items, err := ir.GetAllItems(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">itemsMap := make(map[uint64]model.Item)
        for _, item := range *items </span><span class="cov8" title="1">{
                itemsMap[item.Id] = item
        }</span>

        <span class="cov8" title="1">return &amp;CachedDig{
                tags:  tagsMap,
                items: itemsMap,
        }, nil</span>
}

type CachedDig struct {
        tags  map[string]model.Tag
        items map[uint64]model.Item
}

func (d *CachedDig) GetBelongingItems(ctx context.Context, path string) (*[]model.Item, error) <span class="cov8" title="1">{
        return newFsDirectory(directories.NormalizeDirectoryPath(path)).getItems(ctx, d)
}</span>

func (d *CachedDig) GetBelongingItem(ctx context.Context, path string, filename string) (*model.Item, error) <span class="cov0" title="0">{
        return newFsDirectory(directories.NormalizeDirectoryPath(path)).getItem(ctx, d, filename)
}</span>

func (d *CachedDig) GetDirectoryTag(ctx context.Context, path string) (*model.Tag, error) <span class="cov8" title="1">{
        tag, ok := d.tags[path]
        if !ok </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return &amp;tag, nil</span>
}

func (d *CachedDig) GetItems(ctx context.Context, ids []uint64) (*[]model.Item, error) <span class="cov8" title="1">{
        result := make([]model.Item, 0)
        for _, id := range ids </span><span class="cov8" title="1">{
                item, ok := d.items[id]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">result = append(result, item)</span>
        }

        <span class="cov8" title="1">return &amp;result, nil</span>
}

func (d *CachedDig) GetItemByTitle(ctx context.Context, tag *model.Tag, title string) (*model.Item, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented")
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package fssync

import (
        "context"
        "my-collection/server/pkg/bl/directories"
        "my-collection/server/pkg/bl/items"
        "my-collection/server/pkg/bl/tags"
        "my-collection/server/pkg/model"

        "github.com/go-errors/errors"
        "gorm.io/gorm"
)

type BelongingItemDbReader interface {
        GetDirectoryTag(ctx context.Context, path string) (*model.Tag, error)
        GetItems(ctx context.Context, ids []uint64) (*[]model.Item, error)
        GetItemByTitle(ctx context.Context, tag *model.Tag, title string) (*model.Item, error)
}

func wrapDb(tr model.TagReader, ir model.ItemReader) BelongingItemDbReader <span class="cov8" title="1">{
        return &amp;dbBelongingItemDbReader{
                tr: tr,
                ir: ir,
        }
}</span>

type dbBelongingItemDbReader struct {
        tr model.TagReader
        ir model.ItemReader
}

func (d *dbBelongingItemDbReader) GetDirectoryTag(ctx context.Context, path string) (*model.Tag, error) <span class="cov8" title="1">{
        return tags.GetChildTag(ctx, d.tr, directories.GetDirectoriesTagId(), path)
}</span>

func (d *dbBelongingItemDbReader) GetItemByTitle(ctx context.Context, tag *model.Tag, title string) (*model.Item, error) <span class="cov8" title="1">{
        return tags.GetItemByTitle(ctx, d.ir, tag, title)
}</span>

func (d *dbBelongingItemDbReader) GetItems(ctx context.Context, ids []uint64) (*[]model.Item, error) <span class="cov8" title="1">{
        if len(ids) == 0 </span><span class="cov8" title="1">{
                result := make([]model.Item, 0)
                return &amp;result, nil
        }</span>

        <span class="cov8" title="1">return d.ir.GetItems(ctx, ids)</span>
}

func newFsDirectory(path string) *FsDirectory <span class="cov8" title="1">{
        return &amp;FsDirectory{
                path: path,
        }
}</span>

type FsDirectory struct {
        path string
}

func (d *FsDirectory) getTag(ctx context.Context, tr BelongingItemDbReader) (*model.Tag, error) <span class="cov8" title="1">{
        tag, err := tr.GetDirectoryTag(ctx, d.path)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">return tag, nil</span>
}

func (d *FsDirectory) removeItem(ctx context.Context, tr model.TagReader, iw model.ItemWriter, item *model.Item) error <span class="cov8" title="1">{
        tag, err := d.getTag(ctx, wrapDb(tr, nil))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if tag == nil </span><span class="cov0" title="0">{
                return errors.Errorf("'directory tag' not found %s", d.path)
        }</span>

        <span class="cov8" title="1">return iw.RemoveTagFromItem(ctx, item.Id, tag.Id)</span>
}

func (d *FsDirectory) addItem(ctx context.Context, tr model.TagReader, iw model.ItemWriter, item *model.Item) error <span class="cov8" title="1">{
        tag, err := d.getTag(ctx, wrapDb(tr, nil))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if tag == nil </span><span class="cov0" title="0">{
                return errors.Errorf("'directory tag' not found %s", d.path)
        }</span>

        <span class="cov8" title="1">item.Tags = append(item.Tags, tag)
        return iw.CreateOrUpdateItem(ctx, item)</span>
}

func (d *FsDirectory) getItem(ctx context.Context, tr BelongingItemDbReader, filename string) (*model.Item, error) <span class="cov8" title="1">{
        tag, err := d.getTag(ctx, tr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if tag == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">return tr.GetItemByTitle(ctx, tag, items.TitleFromFileName(filename))</span>
}

func (d *FsDirectory) getItems(ctx context.Context, tr BelongingItemDbReader) (*[]model.Item, error) <span class="cov8" title="1">{
        tag, err := d.getTag(ctx, tr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if tag == nil </span><span class="cov8" title="1">{
                empty := make([]model.Item, 0)
                return &amp;empty, nil
        }</span>

        <span class="cov8" title="1">itemIds := make([]uint64, 0)
        for _, item := range tag.Items </span><span class="cov8" title="1">{
                itemIds = append(itemIds, item.Id)
        }</span>

        <span class="cov8" title="1">items, err := tr.GetItems(ctx, itemIds)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package fssync

import (
        "context"
        "my-collection/server/pkg/bl/directories"
        "my-collection/server/pkg/bl/tags"
        "my-collection/server/pkg/db"
        "my-collection/server/pkg/directorytree"
        "my-collection/server/pkg/model"
        "my-collection/server/pkg/relativasor"
        "my-collection/server/pkg/utils"
        "os"
        "time"

        "github.com/go-errors/errors"
        "github.com/op/go-logging"
)

var logger = logging.MustGetLogger("fsmanager")

func NewFsManager(ctx context.Context, db db.Database, filesFilter directorytree.FilesFilter, checkInterval time.Duration) (*FsManager, error) <span class="cov8" title="1">{
        if err := directories.AddRootDirectory(ctx, db); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;FsManager{
                filesFilter:   filesFilter,
                checkInterval: checkInterval,
                db:            db,
                changeChannel: make(chan bool),
        }, nil</span>
}

type FsManager struct {
        utils.PushSender
        filesFilter   directorytree.FilesFilter
        checkInterval time.Duration
        db            db.Database
        changeChannel chan bool
}

func (f *FsManager) Watch(ctx context.Context) error <span class="cov0" title="0">{
        ctx = utils.ContextWithSubject(ctx, "fs_manager")

        if err := f.Sync(ctx); err != nil </span><span class="cov0" title="0">{
                utils.LogError("Error in FS Watch", err)
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-f.changeChannel:<span class="cov0" title="0">
                        if err := f.Sync(ctx); err != nil </span><span class="cov0" title="0">{
                                utils.LogError("Error in FS Watch", err)
                        }</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil</span>
                case &lt;-time.After(f.checkInterval):<span class="cov0" title="0">
                        if err := f.Sync(ctx); err != nil </span><span class="cov0" title="0">{
                                utils.LogError("Error in FS Watch", err)
                        }</span>
                }
        }
}

func (f *FsManager) DirectoryChanged() <span class="cov0" title="0">{
        select </span>{
        case f.changeChannel &lt;- true:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
        }
}

func (f *FsManager) GetBelongingItems(ctx context.Context, path string) (*[]model.Item, error) <span class="cov8" title="1">{
        return newFsDirectory(directories.NormalizeDirectoryPath(path)).getItems(ctx, wrapDb(f.db, f.db))
}</span>

func (f *FsManager) GetBelongingItem(ctx context.Context, path string, filename string) (*model.Item, error) <span class="cov8" title="1">{
        return newFsDirectory(directories.NormalizeDirectoryPath(path)).getItem(ctx, wrapDb(f.db, f.db), filename)
}</span>

func (f *FsManager) AddBelongingItem(ctx context.Context, item *model.Item) error <span class="cov8" title="1">{
        return newFsDirectory(item.Origin).addItem(ctx, f.db, f.db, item)
}</span>

func (f *FsManager) GetAutoTags(ctx context.Context, path string) ([]*model.Tag, error) <span class="cov8" title="1">{
        directory, err := directories.GetDirectory(ctx, f.db, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return tags.GetOrCreateTags(ctx, f.db, directories.BuildDirectoryTags(directory))</span>
}

func (f *FsManager) GetFileMetadata(path string) (int64, int64, error) <span class="cov8" title="1">{
        file, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, errors.Wrap(err, 1)
        }</span>

        <span class="cov8" title="1">return file.ModTime().UnixMilli(), file.Size(), nil</span>
}

func (f *FsManager) runSync(ctx context.Context) (bool, error) <span class="cov8" title="1">{
        dig, err := NewCachedDig(ctx, f.db, f.db)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">fsSync, err := newFsSyncer(ctx, relativasor.GetRootDirectory(), f.db, dig, f.filesFilter)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">hasChanges, errors := fsSync.sync(ctx, f.db, f, f, f)

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                logger.Errorf("FS Sync finished with %d errors", len(errors))
                for _, err := range errors </span><span class="cov0" title="0">{
                        utils.LogError("Error in FS Sync", err)
                }</span>

                <span class="cov0" title="0">return hasChanges, errors[0]</span>
        }

        <span class="cov8" title="1">return hasChanges, nil</span>
}

func (f *FsManager) Sync(ctx context.Context) error <span class="cov8" title="1">{
        var lastError error
        hasAnyChange := false

        hasChanges := true
        for hasChanges </span><span class="cov8" title="1">{
                var err error
                hasChanges, err = f.runSync(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        lastError = err
                }</span>
                <span class="cov8" title="1">if hasChanges </span><span class="cov8" title="1">{
                        hasAnyChange = hasChanges
                }</span>
        }

        <span class="cov8" title="1">if hasAnyChange </span><span class="cov8" title="1">{
                f.Push(model.PushMessage{MessageType: model.PUSH_FS_CHANGE, Payload: ""})
        }</span>

        <span class="cov8" title="1">return lastError</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package fssync

import (
        "context"
        "my-collection/server/pkg/bl/directories"
        "my-collection/server/pkg/bl/items"
        "my-collection/server/pkg/bl/tags"
        "my-collection/server/pkg/directorytree"
        "my-collection/server/pkg/model"
        "my-collection/server/pkg/relativasor"
        "path/filepath"
        "strings"

        "github.com/go-errors/errors"
        "gorm.io/gorm"
)

func newFsSyncer(ctx context.Context, path string, db model.Database, dig model.DirectoryItemsGetter, filter directorytree.FilesFilter) (*fsSyncer, error) <span class="cov8" title="1">{
        exists, err := directories.DirectoryExists(ctx, db, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                return nil, errors.Errorf("directory not found in db %s", path)
        }</span>

        <span class="cov8" title="1">rootfs, err := directorytree.BuildFromPath(path, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rootdb, err := directorytree.BuildFromDb(ctx, db, dig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">diff := directorytree.Compare(rootfs, rootdb)
        stales := directorytree.FindStales(rootdb)

        return &amp;fsSyncer{
                diff:   diff,
                stales: stales,
                ctx:    ctx,
        }, nil</span>
}

type fsSyncer struct {
        stales *directorytree.Stale
        diff   *directorytree.Diff
        ctx    context.Context
}

func (f *fsSyncer) hasFsChanges() bool <span class="cov8" title="1">{
        return f.stales.HasChanges() || f.diff.HasChanges()
}</span>

func (f *fsSyncer) sync(ctx context.Context, db model.Database, digs model.DirectoryItemsGetterSetter,
        datg model.DirectoryAutoTagsGetter, fmg model.FileMetadataGetter) (bool, []error) <span class="cov8" title="1">{

        // TODO:
        // &gt; remove moved dirs and files from stale dirs and items
        // &gt; tag title+parent must be unique (representing the full origin location)
        // &gt; remove auto tags when removing directory
        // &gt; update directory path when renaming dirs
        // &gt; remove auto tags from items if they removed from their dir (how do we know its an auto tag?)
        // &gt; redefine auto tags - what are they? maybe auto tags, allow more flexibility with them

        errs := make([]error, 0)
        errs = append(errs, addMissingDirectoryTags(ctx, db, db)...)

        if f.hasFsChanges() </span><span class="cov8" title="1">{
                f.debugPrint()
                errs = append(errs, removeStaleItems(ctx, digs, db, f.stales.Files)...)
                errs = append(errs, removeStaleDirs(ctx, db, db, f.stales.Dirs)...)
                errs = append(errs, addMissingDirs(ctx, db, f.diff.AddedDirectories)...)
                errs = append(errs, renameDirs(ctx, db, db, db, f.diff.MovedDirectories)...)
                errs = append(errs, renameFiles(ctx, db, db, db, f.diff.MovedFiles)...)
                errs = append(errs, removeDeletedDirs(ctx, db, db, f.diff.RemovedDirectories)...)
                errs = append(errs, removeDeletedFiles(ctx, digs, db, f.diff.RemovedFiles)...)
                errs = append(errs, addNewFiles(ctx, db, digs, datg, fmg, f.diff.AddedFiles)...)
        }</span>

        <span class="cov8" title="1">anyItemChanged, tagsErrs := syncAutoTags(ctx, db, db, db, datg)
        errs = append(errs, tagsErrs...)
        return f.hasFsChanges() || anyItemChanged, errs</span>
}

func (f *fsSyncer) debugPrint() <span class="cov8" title="1">{
        logger.Debugf("Sync starting")

        if len(f.stales.Dirs) &gt; 0 </span><span class="cov0" title="0">{
                logger.Debugf("%d Stale directories - [%s]", len(f.stales.Dirs), strings.Join(f.stales.Dirs, ", "))
        }</span>

        <span class="cov8" title="1">if len(f.stales.Files) &gt; 0 </span><span class="cov8" title="1">{
                logger.Debugf("%d Stale files - [%s]", len(f.stales.Files), strings.Join(f.stales.Files, ", "))
        }</span>

        <span class="cov8" title="1">if len(f.diff.AddedDirectories) &gt; 0 </span><span class="cov8" title="1">{
                logger.Debugf("%d Added directories - [%s]", len(f.diff.AddedDirectories), strings.Join(f.diff.ChangesToString(f.diff.AddedDirectories), ", "))
        }</span>

        <span class="cov8" title="1">if len(f.diff.RemovedDirectories) &gt; 0 </span><span class="cov8" title="1">{
                logger.Debugf("%d Removed directories - [%s]", len(f.diff.RemovedDirectories), strings.Join(f.diff.ChangesToString(f.diff.RemovedDirectories), ", "))
        }</span>

        <span class="cov8" title="1">if len(f.diff.AddedFiles) &gt; 0 </span><span class="cov8" title="1">{
                logger.Debugf("%d Added files - [%s]", len(f.diff.AddedFiles), strings.Join(f.diff.ChangesToString(f.diff.AddedFiles), ", "))
        }</span>

        <span class="cov8" title="1">if len(f.diff.RemovedFiles) &gt; 0 </span><span class="cov8" title="1">{
                logger.Debugf("%d Removed files - [%s]", len(f.diff.RemovedFiles), strings.Join(f.diff.ChangesToString(f.diff.RemovedFiles), ", "))
        }</span>

        <span class="cov8" title="1">if len(f.diff.MovedDirectories) &gt; 0 </span><span class="cov8" title="1">{
                logger.Debugf("%d Moved directories - [%s]", len(f.diff.MovedDirectories), strings.Join(f.diff.ChangesToString(f.diff.MovedDirectories), ", "))
        }</span>

        <span class="cov8" title="1">if len(f.diff.MovedFiles) &gt; 0 </span><span class="cov8" title="1">{
                logger.Debugf("%d Moved files - [%s]", len(f.diff.MovedFiles), strings.Join(f.diff.ChangesToString(f.diff.MovedFiles), ", "))
        }</span>
}

func addMissingDirectoryTags(ctx context.Context, dr model.DirectoryReader, trw model.TagReaderWriter) []error <span class="cov8" title="1">{
        errs := make([]error, 0)
        allDirectories, err := dr.GetAllDirectories(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return append(errs, err)
        }</span>

        <span class="cov8" title="1">for i, dir := range *allDirectories </span><span class="cov8" title="1">{
                if err := addMissingDirectoryTag(ctx, trw, &amp;dir); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
                <span class="cov8" title="1">if i+1%100 == 0 </span><span class="cov0" title="0">{
                        logger.Debugf("Added %d/%d directory tags", i, len(*allDirectories))
                }</span>
        }

        <span class="cov8" title="1">return errs</span>
}

func addMissingDirectoryTag(ctx context.Context, trw model.TagReaderWriter, dir *model.Directory) error <span class="cov8" title="1">{
        if directories.IsExcluded(dir) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">_, err := tags.GetOrCreateChildTag(ctx, trw, directories.GetDirectoriesTagId(), dir.Path)
        return err</span>
}

func removeStaleItems(ctx context.Context, dig model.DirectoryItemsGetter, iw model.ItemWriter, files []string) []error <span class="cov8" title="1">{
        errs := make([]error, 0)
        for _, file := range files </span><span class="cov8" title="1">{
                errs = append(errs, removeItem(ctx, dig, iw, file)...)
        }</span>

        <span class="cov8" title="1">return errs</span>
}

func removeItem(ctx context.Context, dig model.DirectoryItemsGetter, iw model.ItemWriter, file string) []error <span class="cov8" title="1">{
        dirpath := directories.NormalizeDirectoryPath(filepath.Dir(file))
        item, err := dig.GetBelongingItem(ctx, dirpath, filepath.Base(file))
        if err != nil </span><span class="cov0" title="0">{
                return []error{err}
        }</span>

        <span class="cov8" title="1">if item != nil </span><span class="cov8" title="1">{
                return items.RemoveItemAndItsAssociations(ctx, iw, item.Id)
        }</span>

        <span class="cov8" title="1">return []error{}</span>
}

func removeStaleDirs(ctx context.Context, trw model.TagReaderWriter, dw model.DirectoryWriter, dirs []string) []error <span class="cov8" title="1">{
        errs := make([]error, 0)
        for _, path := range dirs </span><span class="cov0" title="0">{
                errs = append(errs, removeDir(ctx, trw, dw, path)...)
        }</span>

        <span class="cov8" title="1">return errs</span>
}

func removeDir(ctx context.Context, trw model.TagReaderWriter, dw model.DirectoryWriter, path string) []error <span class="cov8" title="1">{
        errs := make([]error, 0)
        dir := newFsDirectory(directories.NormalizeDirectoryPath(path))
        tag, err := dir.getTag(ctx, wrapDb(trw, nil))
        if err != nil </span><span class="cov0" title="0">{
                errs = append(errs, err)
        }</span> else<span class="cov8" title="1"> if tag != nil </span><span class="cov8" title="1">{
                errs = append(errs, tags.RemoveTagAndItsAssociations(ctx, trw, tag)...)
        }</span>

        <span class="cov8" title="1">if err := dw.RemoveDirectory(ctx, directories.NormalizeDirectoryPath(path)); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, err)
        }</span>

        <span class="cov8" title="1">return errs</span>
}

func addMissingDirs(ctx context.Context, drw model.DirectoryReaderWriter, addedDirectories []directorytree.Change) []error <span class="cov8" title="1">{
        errs := make([]error, 0)
        for i, change := range addedDirectories </span><span class="cov8" title="1">{
                shouldInclude := directories.ShouldInclude(ctx, drw, change.Path1)
                err := directories.AddDirectoryIfMissing(ctx, drw, change.Path1, !shouldInclude)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
                <span class="cov8" title="1">if i+1%100 == 0 </span><span class="cov0" title="0">{
                        logger.Debugf("Added %d/%d directories", i, len(addedDirectories))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func addNewFiles(ctx context.Context, iw model.ItemWriter, digs model.DirectoryItemsGetterSetter, datg model.DirectoryAutoTagsGetter,
        fmg model.FileMetadataGetter, addedFiles []directorytree.Change) []error <span class="cov8" title="1">{
        errs := make([]error, 0)
        for i, change := range addedFiles </span><span class="cov8" title="1">{
                dirpath := directories.NormalizeDirectoryPath(filepath.Dir(change.Path1))
                item, err := digs.GetBelongingItem(ctx, dirpath, filepath.Base(change.Path1))
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                        continue</span>
                }

                <span class="cov8" title="1">if err := handleFile(ctx, iw, digs, datg, fmg, item, dirpath, change.Path1); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
                <span class="cov8" title="1">if i+1%100 == 0 </span><span class="cov0" title="0">{
                        logger.Debugf("Added %d/%d files", i, len(addedFiles))
                }</span>
        }

        <span class="cov8" title="1">return errs</span>
}

func handleFile(ctx context.Context, iw model.ItemWriter, digs model.DirectoryItemsGetterSetter, datg model.DirectoryAutoTagsGetter,
        fmg model.FileMetadataGetter, item *model.Item, dirpath string, path string) error <span class="cov8" title="1">{
        autoTags, err := datg.GetAutoTags(ctx, dirpath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if item != nil </span><span class="cov0" title="0">{
                _, err := items.EnsureItemHaveTags(ctx, iw, item, autoTags)
                return err
        }</span> else<span class="cov8" title="1"> {
                return handleNewFile(ctx, digs, fmg, dirpath, path, autoTags)
        }</span>
}

func handleNewFile(ctx context.Context, digs model.DirectoryItemsGetterSetter, fmg model.FileMetadataGetter,
        dirpath string, path string, autoTags []*model.Tag) error <span class="cov8" title="1">{
        item, err := items.BuildItemFromPath(dirpath, relativasor.GetAbsoluteFile(path), fmg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">item.Tags = autoTags
        return digs.AddBelongingItem(ctx, item)</span>
}

func removeDeletedDirs(ctx context.Context, trw model.TagReaderWriter, dw model.DirectoryWriter, deletedDirs []directorytree.Change) []error <span class="cov8" title="1">{
        errs := make([]error, 0)
        for _, dir := range deletedDirs </span><span class="cov8" title="1">{
                errs = append(errs, removeDir(ctx, trw, dw, dir.Path1)...)
        }</span>

        <span class="cov8" title="1">return errs</span>
}

func removeDeletedFiles(ctx context.Context, dig model.DirectoryItemsGetter, iw model.ItemWriter, deletedFiles []directorytree.Change) []error <span class="cov8" title="1">{
        errs := make([]error, 0)
        for _, file := range deletedFiles </span><span class="cov8" title="1">{
                errs = append(errs, removeItem(ctx, dig, iw, file.Path1)...)
        }</span>

        <span class="cov8" title="1">return errs</span>
}

func renameDirs(ctx context.Context, trw model.TagReaderWriter, drw model.DirectoryReaderWriter,
        irw model.ItemReaderWriter, movedDirs []directorytree.Change) []error <span class="cov8" title="1">{
        errs := make([]error, 0)
        for _, dir := range movedDirs </span><span class="cov8" title="1">{
                src := dir.Path1
                dst := dir.Path2

                if err := moveDir(ctx, trw, drw, irw, src, dst); err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, err...)
                }</span>
        }

        <span class="cov8" title="1">return errs</span>
}

func updateItemsLocation(ctx context.Context, trw model.TagReaderWriter, irw model.ItemReaderWriter, path string) []error <span class="cov8" title="1">{
        dirpath := directories.NormalizeDirectoryPath(path)
        errs := make([]error, 0)
        dir := newFsDirectory(dirpath)
        belongingItems, err := dir.getItems(ctx, wrapDb(trw, irw))
        if err != nil </span><span class="cov0" title="0">{
                return append(errs, err)
        }</span>

        <span class="cov8" title="1">for _, item := range *belongingItems </span><span class="cov0" title="0">{
                if err := items.UpdateFileLocation(ctx, irw, &amp;item, dirpath, filepath.Join(item.Origin, item.Title), ""); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
        }

        <span class="cov8" title="1">return errs</span>
}

func moveDir(ctx context.Context, trw model.TagReaderWriter, drw model.DirectoryReaderWriter,
        irw model.ItemReaderWriter, src string, dst string) []error <span class="cov8" title="1">{
        errs := make([]error, 0)
        dstDirpath := directories.NormalizeDirectoryPath(dst)
        dstdir, err := directories.GetDirectory(ctx, drw, dstDirpath)
        if err != nil &amp;&amp; !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return append(errs, err)
        }</span>
        <span class="cov8" title="1">if dstdir == nil </span><span class="cov0" title="0">{
                return removeDir(ctx, trw, drw, src)
        }</span>

        <span class="cov8" title="1">srcDirpath := directories.NormalizeDirectoryPath(src)
        srcdir, err := directories.GetDirectory(ctx, drw, srcDirpath)
        if err != nil </span><span class="cov0" title="0">{
                return append(errs, err)
        }</span>
        <span class="cov8" title="1">if srcdir == nil </span><span class="cov0" title="0">{
                return append(errs, errors.Errorf("source directory not exists %s", src))
        }</span>

        <span class="cov8" title="1">if err := directories.UpdatePath(ctx, drw, srcdir, dst); err != nil </span><span class="cov0" title="0">{
                return append(errs, err)
        }</span>

        <span class="cov8" title="1">if directories.IsExcluded(srcdir) </span><span class="cov0" title="0">{
                return errs
        }</span>

        <span class="cov8" title="1">return append(errs, updateItemsLocation(ctx, trw, irw, dst)...)</span>
}

func renameFiles(ctx context.Context, trw model.TagReaderWriter, drw model.DirectoryReaderWriter,
        irw model.ItemReaderWriter, movedFiles []directorytree.Change) []error <span class="cov8" title="1">{
        errs := make([]error, 0)
        for _, file := range movedFiles </span><span class="cov8" title="1">{
                src := file.Path1
                dst := file.Path2

                if err := moveFile(ctx, trw, drw, irw, src, dst); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
        }

        <span class="cov8" title="1">return errs</span>
}

func moveFile(ctx context.Context, trw model.TagReaderWriter, drw model.DirectoryReaderWriter,
        irw model.ItemReaderWriter, src string, dst string) error <span class="cov8" title="1">{
        if err := validateReadyDirectory(ctx, trw, drw, dst); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">srcDirpath := directories.NormalizeDirectoryPath(filepath.Dir(src))
        srcDir := newFsDirectory(srcDirpath)
        item, err := srcDir.getItem(ctx, wrapDb(trw, irw), items.TitleFromFileName(src))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if item == nil </span><span class="cov0" title="0">{
                return errors.Errorf("original item not found %s", src)
        }</span>

        <span class="cov8" title="1">dstDirpath := directories.NormalizeDirectoryPath(filepath.Dir(dst))
        if err := items.UpdateFileLocation(ctx, irw, item, dstDirpath, dst, ""); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">dstDir := newFsDirectory(dstDirpath)
        if err := dstDir.addItem(ctx, trw, irw, item); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return srcDir.removeItem(ctx, trw, irw, item)</span>
}

func validateReadyDirectory(ctx context.Context, trw model.TagReaderWriter, drw model.DirectoryReaderWriter, path string) error <span class="cov8" title="1">{
        dir, err := directories.ValidateReadyDirectory(ctx, drw, filepath.Dir(path))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return addMissingDirectoryTag(ctx, trw, dir)</span>
}

func syncAutoTags(ctx context.Context, tr model.TagReader, irw model.ItemReaderWriter,
        dr model.DirectoryReader, datg model.DirectoryAutoTagsGetter) (bool, []error) <span class="cov8" title="1">{
        errs := make([]error, 0)
        allDirectories, err := dr.GetAllDirectories(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return false, append(errs, err)
        }</span>

        <span class="cov8" title="1">anyItemChanged := false
        for _, dir := range *allDirectories </span><span class="cov8" title="1">{
                autoTags, err := datg.GetAutoTags(ctx, dir.Path)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                        continue</span>
                }

                <span class="cov8" title="1">itemChanged, syncErrs := syncAutoTagsForDir(ctx, tr, irw, autoTags, &amp;dir)
                errs = append(errs, syncErrs...)
                anyItemChanged = anyItemChanged || itemChanged</span>
        }

        <span class="cov8" title="1">return anyItemChanged, errs</span>
}

func syncAutoTagsForDir(ctx context.Context, tr model.TagReader, irw model.ItemReaderWriter,
        autoTags []*model.Tag, dir *model.Directory) (bool, []error) <span class="cov8" title="1">{
        errs := make([]error, 0)
        fsdir := newFsDirectory(dir.Path)
        belongingItems, err := fsdir.getItems(ctx, wrapDb(tr, irw))
        if err != nil </span><span class="cov0" title="0">{
                return false, append(errs, err)
        }</span>

        <span class="cov8" title="1">anyItemChanged := false
        for _, item := range *belongingItems </span><span class="cov8" title="1">{
                itemChanged, err := items.EnsureItemHaveTags(ctx, irw, &amp;item, autoTags)
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
                <span class="cov8" title="1">anyItemChanged = anyItemChanged || itemChanged</span>
        }

        <span class="cov8" title="1">return anyItemChanged, errs</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package mixondemand

import (
        "context"
        "fmt"

        "my-collection/server/pkg/bl/special_tags"
        "my-collection/server/pkg/bl/tag_annotations"
        "my-collection/server/pkg/bl/tags"
        "my-collection/server/pkg/model"
        "my-collection/server/pkg/suggestions"
        "time"
)

type mixOnDemandDb interface {
        model.TagReaderWriter
        model.ItemReader
        model.TagAnnotationReaderWriter
}

func New(ctx context.Context, db mixOnDemandDb, mixOnDemandItemsCount int) (*MixOnDemand, error) <span class="cov0" title="0">{
        d, err := db.GetTag(ctx, special_tags.MixOnDemandTag)
        if err != nil </span><span class="cov0" title="0">{
                if err := db.CreateOrUpdateTag(ctx, special_tags.MixOnDemandTag); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                special_tags.MixOnDemandTag = d
        }</span>

        <span class="cov0" title="0">return &amp;MixOnDemand{
                db:                    db,
                mixOnDemandItemsCount: mixOnDemandItemsCount,
        }, nil</span>
}

type MixOnDemand struct {
        db                    mixOnDemandDb
        mixOnDemandItemsCount int
}

func (d *MixOnDemand) GetCurrentTime() time.Time <span class="cov0" title="0">{
        return time.Now()
}</span>

func (d *MixOnDemand) GenerateMixOnDemand(ctx context.Context, ctg model.CurrentTimeGetter, desc string, tags []model.Tag) (*model.Tag, error) <span class="cov0" title="0">{
        tag, err := prepareMixOnDemandTag(ctx, d.db, ctg, desc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result, err := suggestions.GetSuggestionsForTags(ctx, d.db, d.db, &amp;tags, d.mixOnDemandItemsCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tag.Items = result
        return tag, d.db.CreateOrUpdateTag(ctx, tag)</span>
}

func getCurrentMixOnDemandTitle(desc string, ctg model.CurrentTimeGetter) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s - %s", desc, ctg.GetCurrentTime().Format("02-Jan-2006 15:04:05"))
}</span>

func getCurrentMixOnDemandAnnotation(ctg model.CurrentTimeGetter) string <span class="cov0" title="0">{
        return ctg.GetCurrentTime().Format("Jan-2006")
}</span>

func prepareMixOnDemandTag(ctx context.Context, db mixOnDemandDb, ctg model.CurrentTimeGetter, desc string) (*model.Tag, error) <span class="cov0" title="0">{
        tag, err := tags.GetOrCreateChildTag(ctx, db, special_tags.MixOnDemandTag.Id, getCurrentMixOnDemandTitle(desc, ctg))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">_, err = tag_annotations.AddAnnotationToTag(ctx, db, db, tag.Id, model.TagAnnotation{
                Title: getCurrentMixOnDemandAnnotation(ctg),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return tag, err</span>
}

func GetMixOnDemandTagId() uint64 <span class="cov8" title="1">{
        return special_tags.MixOnDemandTag.Id
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: interfaces.go
//
// Generated by this command:
//
//        mockgen -package model -source interfaces.go -destination interfaces_mock.go
//

// Package model is a generated GoMock package.
package model

import (
        context "context"
        reflect "reflect"
        time "time"

        gomock "go.uber.org/mock/gomock"
)

// MockItemReader is a mock of ItemReader interface.
type MockItemReader struct {
        ctrl     *gomock.Controller
        recorder *MockItemReaderMockRecorder
        isgomock struct{}
}

// MockItemReaderMockRecorder is the mock recorder for MockItemReader.
type MockItemReaderMockRecorder struct {
        mock *MockItemReader
}

// NewMockItemReader creates a new mock instance.
func NewMockItemReader(ctrl *gomock.Controller) *MockItemReader <span class="cov0" title="0">{
        mock := &amp;MockItemReader{ctrl: ctrl}
        mock.recorder = &amp;MockItemReaderMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockItemReader) EXPECT() *MockItemReaderMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetAllItems mocks base method.
func (m *MockItemReader) GetAllItems(ctx context.Context) (*[]Item, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllItems", ctx)
        ret0, _ := ret[0].(*[]Item)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllItems indicates an expected call of GetAllItems.
func (mr *MockItemReaderMockRecorder) GetAllItems(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllItems", reflect.TypeOf((*MockItemReader)(nil).GetAllItems), ctx)
}</span>

// GetItem mocks base method.
func (m *MockItemReader) GetItem(ctx context.Context, conds ...any) (*Item, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetItem", varargs...)
        ret0, _ := ret[0].(*Item)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetItem indicates an expected call of GetItem.
func (mr *MockItemReaderMockRecorder) GetItem(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItem", reflect.TypeOf((*MockItemReader)(nil).GetItem), varargs...)
}</span>

// GetItems mocks base method.
func (m *MockItemReader) GetItems(ctx context.Context, conds ...any) (*[]Item, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetItems", varargs...)
        ret0, _ := ret[0].(*[]Item)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetItems indicates an expected call of GetItems.
func (mr *MockItemReaderMockRecorder) GetItems(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItems", reflect.TypeOf((*MockItemReader)(nil).GetItems), varargs...)
}</span>

// MockItemWriter is a mock of ItemWriter interface.
type MockItemWriter struct {
        ctrl     *gomock.Controller
        recorder *MockItemWriterMockRecorder
        isgomock struct{}
}

// MockItemWriterMockRecorder is the mock recorder for MockItemWriter.
type MockItemWriterMockRecorder struct {
        mock *MockItemWriter
}

// NewMockItemWriter creates a new mock instance.
func NewMockItemWriter(ctrl *gomock.Controller) *MockItemWriter <span class="cov0" title="0">{
        mock := &amp;MockItemWriter{ctrl: ctrl}
        mock.recorder = &amp;MockItemWriterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockItemWriter) EXPECT() *MockItemWriterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateOrUpdateItem mocks base method.
func (m *MockItemWriter) CreateOrUpdateItem(ctx context.Context, item *Item) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateOrUpdateItem", ctx, item)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateOrUpdateItem indicates an expected call of CreateOrUpdateItem.
func (mr *MockItemWriterMockRecorder) CreateOrUpdateItem(ctx, item any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrUpdateItem", reflect.TypeOf((*MockItemWriter)(nil).CreateOrUpdateItem), ctx, item)
}</span>

// RemoveItem mocks base method.
func (m *MockItemWriter) RemoveItem(ctx context.Context, itemId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveItem", ctx, itemId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveItem indicates an expected call of RemoveItem.
func (mr *MockItemWriterMockRecorder) RemoveItem(ctx, itemId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveItem", reflect.TypeOf((*MockItemWriter)(nil).RemoveItem), ctx, itemId)
}</span>

// RemoveTagFromItem mocks base method.
func (m *MockItemWriter) RemoveTagFromItem(ctx context.Context, itemId, tagId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveTagFromItem", ctx, itemId, tagId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveTagFromItem indicates an expected call of RemoveTagFromItem.
func (mr *MockItemWriterMockRecorder) RemoveTagFromItem(ctx, itemId, tagId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTagFromItem", reflect.TypeOf((*MockItemWriter)(nil).RemoveTagFromItem), ctx, itemId, tagId)
}</span>

// UpdateItem mocks base method.
func (m *MockItemWriter) UpdateItem(ctx context.Context, item *Item) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateItem", ctx, item)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateItem indicates an expected call of UpdateItem.
func (mr *MockItemWriterMockRecorder) UpdateItem(ctx, item any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateItem", reflect.TypeOf((*MockItemWriter)(nil).UpdateItem), ctx, item)
}</span>

// MockItemReaderWriter is a mock of ItemReaderWriter interface.
type MockItemReaderWriter struct {
        ctrl     *gomock.Controller
        recorder *MockItemReaderWriterMockRecorder
        isgomock struct{}
}

// MockItemReaderWriterMockRecorder is the mock recorder for MockItemReaderWriter.
type MockItemReaderWriterMockRecorder struct {
        mock *MockItemReaderWriter
}

// NewMockItemReaderWriter creates a new mock instance.
func NewMockItemReaderWriter(ctrl *gomock.Controller) *MockItemReaderWriter <span class="cov0" title="0">{
        mock := &amp;MockItemReaderWriter{ctrl: ctrl}
        mock.recorder = &amp;MockItemReaderWriterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockItemReaderWriter) EXPECT() *MockItemReaderWriterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateOrUpdateItem mocks base method.
func (m *MockItemReaderWriter) CreateOrUpdateItem(ctx context.Context, item *Item) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateOrUpdateItem", ctx, item)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateOrUpdateItem indicates an expected call of CreateOrUpdateItem.
func (mr *MockItemReaderWriterMockRecorder) CreateOrUpdateItem(ctx, item any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrUpdateItem", reflect.TypeOf((*MockItemReaderWriter)(nil).CreateOrUpdateItem), ctx, item)
}</span>

// GetAllItems mocks base method.
func (m *MockItemReaderWriter) GetAllItems(ctx context.Context) (*[]Item, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllItems", ctx)
        ret0, _ := ret[0].(*[]Item)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllItems indicates an expected call of GetAllItems.
func (mr *MockItemReaderWriterMockRecorder) GetAllItems(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllItems", reflect.TypeOf((*MockItemReaderWriter)(nil).GetAllItems), ctx)
}</span>

// GetItem mocks base method.
func (m *MockItemReaderWriter) GetItem(ctx context.Context, conds ...any) (*Item, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetItem", varargs...)
        ret0, _ := ret[0].(*Item)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetItem indicates an expected call of GetItem.
func (mr *MockItemReaderWriterMockRecorder) GetItem(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItem", reflect.TypeOf((*MockItemReaderWriter)(nil).GetItem), varargs...)
}</span>

// GetItems mocks base method.
func (m *MockItemReaderWriter) GetItems(ctx context.Context, conds ...any) (*[]Item, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetItems", varargs...)
        ret0, _ := ret[0].(*[]Item)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetItems indicates an expected call of GetItems.
func (mr *MockItemReaderWriterMockRecorder) GetItems(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItems", reflect.TypeOf((*MockItemReaderWriter)(nil).GetItems), varargs...)
}</span>

// RemoveItem mocks base method.
func (m *MockItemReaderWriter) RemoveItem(ctx context.Context, itemId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveItem", ctx, itemId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveItem indicates an expected call of RemoveItem.
func (mr *MockItemReaderWriterMockRecorder) RemoveItem(ctx, itemId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveItem", reflect.TypeOf((*MockItemReaderWriter)(nil).RemoveItem), ctx, itemId)
}</span>

// RemoveTagFromItem mocks base method.
func (m *MockItemReaderWriter) RemoveTagFromItem(ctx context.Context, itemId, tagId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveTagFromItem", ctx, itemId, tagId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveTagFromItem indicates an expected call of RemoveTagFromItem.
func (mr *MockItemReaderWriterMockRecorder) RemoveTagFromItem(ctx, itemId, tagId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTagFromItem", reflect.TypeOf((*MockItemReaderWriter)(nil).RemoveTagFromItem), ctx, itemId, tagId)
}</span>

// UpdateItem mocks base method.
func (m *MockItemReaderWriter) UpdateItem(ctx context.Context, item *Item) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateItem", ctx, item)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateItem indicates an expected call of UpdateItem.
func (mr *MockItemReaderWriterMockRecorder) UpdateItem(ctx, item any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateItem", reflect.TypeOf((*MockItemReaderWriter)(nil).UpdateItem), ctx, item)
}</span>

// MockTagReader is a mock of TagReader interface.
type MockTagReader struct {
        ctrl     *gomock.Controller
        recorder *MockTagReaderMockRecorder
        isgomock struct{}
}

// MockTagReaderMockRecorder is the mock recorder for MockTagReader.
type MockTagReaderMockRecorder struct {
        mock *MockTagReader
}

// NewMockTagReader creates a new mock instance.
func NewMockTagReader(ctrl *gomock.Controller) *MockTagReader <span class="cov0" title="0">{
        mock := &amp;MockTagReader{ctrl: ctrl}
        mock.recorder = &amp;MockTagReaderMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTagReader) EXPECT() *MockTagReaderMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetAllTags mocks base method.
func (m *MockTagReader) GetAllTags(ctx context.Context) (*[]Tag, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllTags", ctx)
        ret0, _ := ret[0].(*[]Tag)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllTags indicates an expected call of GetAllTags.
func (mr *MockTagReaderMockRecorder) GetAllTags(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllTags", reflect.TypeOf((*MockTagReader)(nil).GetAllTags), ctx)
}</span>

// GetTag mocks base method.
func (m *MockTagReader) GetTag(ctx context.Context, conds ...any) (*Tag, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetTag", varargs...)
        ret0, _ := ret[0].(*Tag)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetTag indicates an expected call of GetTag.
func (mr *MockTagReaderMockRecorder) GetTag(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTag", reflect.TypeOf((*MockTagReader)(nil).GetTag), varargs...)
}</span>

// GetTags mocks base method.
func (m *MockTagReader) GetTags(ctx context.Context, conds ...any) (*[]Tag, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetTags", varargs...)
        ret0, _ := ret[0].(*[]Tag)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetTags indicates an expected call of GetTags.
func (mr *MockTagReaderMockRecorder) GetTags(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTags", reflect.TypeOf((*MockTagReader)(nil).GetTags), varargs...)
}</span>

// GetTagsWithoutChildren mocks base method.
func (m *MockTagReader) GetTagsWithoutChildren(ctx context.Context, conds ...any) (*[]Tag, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetTagsWithoutChildren", varargs...)
        ret0, _ := ret[0].(*[]Tag)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetTagsWithoutChildren indicates an expected call of GetTagsWithoutChildren.
func (mr *MockTagReaderMockRecorder) GetTagsWithoutChildren(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTagsWithoutChildren", reflect.TypeOf((*MockTagReader)(nil).GetTagsWithoutChildren), varargs...)
}</span>

// MockTagWriter is a mock of TagWriter interface.
type MockTagWriter struct {
        ctrl     *gomock.Controller
        recorder *MockTagWriterMockRecorder
        isgomock struct{}
}

// MockTagWriterMockRecorder is the mock recorder for MockTagWriter.
type MockTagWriterMockRecorder struct {
        mock *MockTagWriter
}

// NewMockTagWriter creates a new mock instance.
func NewMockTagWriter(ctrl *gomock.Controller) *MockTagWriter <span class="cov0" title="0">{
        mock := &amp;MockTagWriter{ctrl: ctrl}
        mock.recorder = &amp;MockTagWriterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTagWriter) EXPECT() *MockTagWriterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateOrUpdateTag mocks base method.
func (m *MockTagWriter) CreateOrUpdateTag(ctx context.Context, tag *Tag) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateOrUpdateTag", ctx, tag)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateOrUpdateTag indicates an expected call of CreateOrUpdateTag.
func (mr *MockTagWriterMockRecorder) CreateOrUpdateTag(ctx, tag any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrUpdateTag", reflect.TypeOf((*MockTagWriter)(nil).CreateOrUpdateTag), ctx, tag)
}</span>

// RemoveTag mocks base method.
func (m *MockTagWriter) RemoveTag(ctx context.Context, tagId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveTag", ctx, tagId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveTag indicates an expected call of RemoveTag.
func (mr *MockTagWriterMockRecorder) RemoveTag(ctx, tagId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTag", reflect.TypeOf((*MockTagWriter)(nil).RemoveTag), ctx, tagId)
}</span>

// RemoveTagImageFromTag mocks base method.
func (m *MockTagWriter) RemoveTagImageFromTag(ctx context.Context, tagId, imageId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveTagImageFromTag", ctx, tagId, imageId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveTagImageFromTag indicates an expected call of RemoveTagImageFromTag.
func (mr *MockTagWriterMockRecorder) RemoveTagImageFromTag(ctx, tagId, imageId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTagImageFromTag", reflect.TypeOf((*MockTagWriter)(nil).RemoveTagImageFromTag), ctx, tagId, imageId)
}</span>

// UpdateTag mocks base method.
func (m *MockTagWriter) UpdateTag(ctx context.Context, tag *Tag) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateTag", ctx, tag)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateTag indicates an expected call of UpdateTag.
func (mr *MockTagWriterMockRecorder) UpdateTag(ctx, tag any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTag", reflect.TypeOf((*MockTagWriter)(nil).UpdateTag), ctx, tag)
}</span>

// MockTagReaderWriter is a mock of TagReaderWriter interface.
type MockTagReaderWriter struct {
        ctrl     *gomock.Controller
        recorder *MockTagReaderWriterMockRecorder
        isgomock struct{}
}

// MockTagReaderWriterMockRecorder is the mock recorder for MockTagReaderWriter.
type MockTagReaderWriterMockRecorder struct {
        mock *MockTagReaderWriter
}

// NewMockTagReaderWriter creates a new mock instance.
func NewMockTagReaderWriter(ctrl *gomock.Controller) *MockTagReaderWriter <span class="cov0" title="0">{
        mock := &amp;MockTagReaderWriter{ctrl: ctrl}
        mock.recorder = &amp;MockTagReaderWriterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTagReaderWriter) EXPECT() *MockTagReaderWriterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateOrUpdateTag mocks base method.
func (m *MockTagReaderWriter) CreateOrUpdateTag(ctx context.Context, tag *Tag) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateOrUpdateTag", ctx, tag)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateOrUpdateTag indicates an expected call of CreateOrUpdateTag.
func (mr *MockTagReaderWriterMockRecorder) CreateOrUpdateTag(ctx, tag any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrUpdateTag", reflect.TypeOf((*MockTagReaderWriter)(nil).CreateOrUpdateTag), ctx, tag)
}</span>

// GetAllTags mocks base method.
func (m *MockTagReaderWriter) GetAllTags(ctx context.Context) (*[]Tag, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllTags", ctx)
        ret0, _ := ret[0].(*[]Tag)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllTags indicates an expected call of GetAllTags.
func (mr *MockTagReaderWriterMockRecorder) GetAllTags(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllTags", reflect.TypeOf((*MockTagReaderWriter)(nil).GetAllTags), ctx)
}</span>

// GetTag mocks base method.
func (m *MockTagReaderWriter) GetTag(ctx context.Context, conds ...any) (*Tag, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetTag", varargs...)
        ret0, _ := ret[0].(*Tag)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetTag indicates an expected call of GetTag.
func (mr *MockTagReaderWriterMockRecorder) GetTag(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTag", reflect.TypeOf((*MockTagReaderWriter)(nil).GetTag), varargs...)
}</span>

// GetTags mocks base method.
func (m *MockTagReaderWriter) GetTags(ctx context.Context, conds ...any) (*[]Tag, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetTags", varargs...)
        ret0, _ := ret[0].(*[]Tag)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetTags indicates an expected call of GetTags.
func (mr *MockTagReaderWriterMockRecorder) GetTags(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTags", reflect.TypeOf((*MockTagReaderWriter)(nil).GetTags), varargs...)
}</span>

// GetTagsWithoutChildren mocks base method.
func (m *MockTagReaderWriter) GetTagsWithoutChildren(ctx context.Context, conds ...any) (*[]Tag, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetTagsWithoutChildren", varargs...)
        ret0, _ := ret[0].(*[]Tag)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetTagsWithoutChildren indicates an expected call of GetTagsWithoutChildren.
func (mr *MockTagReaderWriterMockRecorder) GetTagsWithoutChildren(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTagsWithoutChildren", reflect.TypeOf((*MockTagReaderWriter)(nil).GetTagsWithoutChildren), varargs...)
}</span>

// RemoveTag mocks base method.
func (m *MockTagReaderWriter) RemoveTag(ctx context.Context, tagId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveTag", ctx, tagId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveTag indicates an expected call of RemoveTag.
func (mr *MockTagReaderWriterMockRecorder) RemoveTag(ctx, tagId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTag", reflect.TypeOf((*MockTagReaderWriter)(nil).RemoveTag), ctx, tagId)
}</span>

// RemoveTagImageFromTag mocks base method.
func (m *MockTagReaderWriter) RemoveTagImageFromTag(ctx context.Context, tagId, imageId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveTagImageFromTag", ctx, tagId, imageId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveTagImageFromTag indicates an expected call of RemoveTagImageFromTag.
func (mr *MockTagReaderWriterMockRecorder) RemoveTagImageFromTag(ctx, tagId, imageId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTagImageFromTag", reflect.TypeOf((*MockTagReaderWriter)(nil).RemoveTagImageFromTag), ctx, tagId, imageId)
}</span>

// UpdateTag mocks base method.
func (m *MockTagReaderWriter) UpdateTag(ctx context.Context, tag *Tag) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateTag", ctx, tag)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateTag indicates an expected call of UpdateTag.
func (mr *MockTagReaderWriterMockRecorder) UpdateTag(ctx, tag any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTag", reflect.TypeOf((*MockTagReaderWriter)(nil).UpdateTag), ctx, tag)
}</span>

// MockTagAnnotationReader is a mock of TagAnnotationReader interface.
type MockTagAnnotationReader struct {
        ctrl     *gomock.Controller
        recorder *MockTagAnnotationReaderMockRecorder
        isgomock struct{}
}

// MockTagAnnotationReaderMockRecorder is the mock recorder for MockTagAnnotationReader.
type MockTagAnnotationReaderMockRecorder struct {
        mock *MockTagAnnotationReader
}

// NewMockTagAnnotationReader creates a new mock instance.
func NewMockTagAnnotationReader(ctrl *gomock.Controller) *MockTagAnnotationReader <span class="cov0" title="0">{
        mock := &amp;MockTagAnnotationReader{ctrl: ctrl}
        mock.recorder = &amp;MockTagAnnotationReaderMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTagAnnotationReader) EXPECT() *MockTagAnnotationReaderMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetTagAnnotation mocks base method.
func (m *MockTagAnnotationReader) GetTagAnnotation(ctx context.Context, conds ...any) (*TagAnnotation, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetTagAnnotation", varargs...)
        ret0, _ := ret[0].(*TagAnnotation)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetTagAnnotation indicates an expected call of GetTagAnnotation.
func (mr *MockTagAnnotationReaderMockRecorder) GetTagAnnotation(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTagAnnotation", reflect.TypeOf((*MockTagAnnotationReader)(nil).GetTagAnnotation), varargs...)
}</span>

// GetTagAnnotations mocks base method.
func (m *MockTagAnnotationReader) GetTagAnnotations(ctx context.Context, tagId uint64) ([]TagAnnotation, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTagAnnotations", ctx, tagId)
        ret0, _ := ret[0].([]TagAnnotation)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTagAnnotations indicates an expected call of GetTagAnnotations.
func (mr *MockTagAnnotationReaderMockRecorder) GetTagAnnotations(ctx, tagId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTagAnnotations", reflect.TypeOf((*MockTagAnnotationReader)(nil).GetTagAnnotations), ctx, tagId)
}</span>

// MockTagAnnotationWriter is a mock of TagAnnotationWriter interface.
type MockTagAnnotationWriter struct {
        ctrl     *gomock.Controller
        recorder *MockTagAnnotationWriterMockRecorder
        isgomock struct{}
}

// MockTagAnnotationWriterMockRecorder is the mock recorder for MockTagAnnotationWriter.
type MockTagAnnotationWriterMockRecorder struct {
        mock *MockTagAnnotationWriter
}

// NewMockTagAnnotationWriter creates a new mock instance.
func NewMockTagAnnotationWriter(ctrl *gomock.Controller) *MockTagAnnotationWriter <span class="cov0" title="0">{
        mock := &amp;MockTagAnnotationWriter{ctrl: ctrl}
        mock.recorder = &amp;MockTagAnnotationWriterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTagAnnotationWriter) EXPECT() *MockTagAnnotationWriterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateTagAnnotation mocks base method.
func (m *MockTagAnnotationWriter) CreateTagAnnotation(ctx context.Context, tagAnnotation *TagAnnotation) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateTagAnnotation", ctx, tagAnnotation)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateTagAnnotation indicates an expected call of CreateTagAnnotation.
func (mr *MockTagAnnotationWriterMockRecorder) CreateTagAnnotation(ctx, tagAnnotation any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTagAnnotation", reflect.TypeOf((*MockTagAnnotationWriter)(nil).CreateTagAnnotation), ctx, tagAnnotation)
}</span>

// RemoveTag mocks base method.
func (m *MockTagAnnotationWriter) RemoveTag(ctx context.Context, tagId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveTag", ctx, tagId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveTag indicates an expected call of RemoveTag.
func (mr *MockTagAnnotationWriterMockRecorder) RemoveTag(ctx, tagId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTag", reflect.TypeOf((*MockTagAnnotationWriter)(nil).RemoveTag), ctx, tagId)
}</span>

// RemoveTagAnnotationFromTag mocks base method.
func (m *MockTagAnnotationWriter) RemoveTagAnnotationFromTag(ctx context.Context, tagId, annotationId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveTagAnnotationFromTag", ctx, tagId, annotationId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveTagAnnotationFromTag indicates an expected call of RemoveTagAnnotationFromTag.
func (mr *MockTagAnnotationWriterMockRecorder) RemoveTagAnnotationFromTag(ctx, tagId, annotationId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTagAnnotationFromTag", reflect.TypeOf((*MockTagAnnotationWriter)(nil).RemoveTagAnnotationFromTag), ctx, tagId, annotationId)
}</span>

// MockTagAnnotationReaderWriter is a mock of TagAnnotationReaderWriter interface.
type MockTagAnnotationReaderWriter struct {
        ctrl     *gomock.Controller
        recorder *MockTagAnnotationReaderWriterMockRecorder
        isgomock struct{}
}

// MockTagAnnotationReaderWriterMockRecorder is the mock recorder for MockTagAnnotationReaderWriter.
type MockTagAnnotationReaderWriterMockRecorder struct {
        mock *MockTagAnnotationReaderWriter
}

// NewMockTagAnnotationReaderWriter creates a new mock instance.
func NewMockTagAnnotationReaderWriter(ctrl *gomock.Controller) *MockTagAnnotationReaderWriter <span class="cov0" title="0">{
        mock := &amp;MockTagAnnotationReaderWriter{ctrl: ctrl}
        mock.recorder = &amp;MockTagAnnotationReaderWriterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTagAnnotationReaderWriter) EXPECT() *MockTagAnnotationReaderWriterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateTagAnnotation mocks base method.
func (m *MockTagAnnotationReaderWriter) CreateTagAnnotation(ctx context.Context, tagAnnotation *TagAnnotation) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateTagAnnotation", ctx, tagAnnotation)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateTagAnnotation indicates an expected call of CreateTagAnnotation.
func (mr *MockTagAnnotationReaderWriterMockRecorder) CreateTagAnnotation(ctx, tagAnnotation any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTagAnnotation", reflect.TypeOf((*MockTagAnnotationReaderWriter)(nil).CreateTagAnnotation), ctx, tagAnnotation)
}</span>

// GetTagAnnotation mocks base method.
func (m *MockTagAnnotationReaderWriter) GetTagAnnotation(ctx context.Context, conds ...any) (*TagAnnotation, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetTagAnnotation", varargs...)
        ret0, _ := ret[0].(*TagAnnotation)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetTagAnnotation indicates an expected call of GetTagAnnotation.
func (mr *MockTagAnnotationReaderWriterMockRecorder) GetTagAnnotation(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTagAnnotation", reflect.TypeOf((*MockTagAnnotationReaderWriter)(nil).GetTagAnnotation), varargs...)
}</span>

// GetTagAnnotations mocks base method.
func (m *MockTagAnnotationReaderWriter) GetTagAnnotations(ctx context.Context, tagId uint64) ([]TagAnnotation, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTagAnnotations", ctx, tagId)
        ret0, _ := ret[0].([]TagAnnotation)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTagAnnotations indicates an expected call of GetTagAnnotations.
func (mr *MockTagAnnotationReaderWriterMockRecorder) GetTagAnnotations(ctx, tagId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTagAnnotations", reflect.TypeOf((*MockTagAnnotationReaderWriter)(nil).GetTagAnnotations), ctx, tagId)
}</span>

// RemoveTag mocks base method.
func (m *MockTagAnnotationReaderWriter) RemoveTag(ctx context.Context, tagId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveTag", ctx, tagId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveTag indicates an expected call of RemoveTag.
func (mr *MockTagAnnotationReaderWriterMockRecorder) RemoveTag(ctx, tagId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTag", reflect.TypeOf((*MockTagAnnotationReaderWriter)(nil).RemoveTag), ctx, tagId)
}</span>

// RemoveTagAnnotationFromTag mocks base method.
func (m *MockTagAnnotationReaderWriter) RemoveTagAnnotationFromTag(ctx context.Context, tagId, annotationId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveTagAnnotationFromTag", ctx, tagId, annotationId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveTagAnnotationFromTag indicates an expected call of RemoveTagAnnotationFromTag.
func (mr *MockTagAnnotationReaderWriterMockRecorder) RemoveTagAnnotationFromTag(ctx, tagId, annotationId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTagAnnotationFromTag", reflect.TypeOf((*MockTagAnnotationReaderWriter)(nil).RemoveTagAnnotationFromTag), ctx, tagId, annotationId)
}</span>

// MockDirectoryReader is a mock of DirectoryReader interface.
type MockDirectoryReader struct {
        ctrl     *gomock.Controller
        recorder *MockDirectoryReaderMockRecorder
        isgomock struct{}
}

// MockDirectoryReaderMockRecorder is the mock recorder for MockDirectoryReader.
type MockDirectoryReaderMockRecorder struct {
        mock *MockDirectoryReader
}

// NewMockDirectoryReader creates a new mock instance.
func NewMockDirectoryReader(ctrl *gomock.Controller) *MockDirectoryReader <span class="cov0" title="0">{
        mock := &amp;MockDirectoryReader{ctrl: ctrl}
        mock.recorder = &amp;MockDirectoryReaderMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDirectoryReader) EXPECT() *MockDirectoryReaderMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetAllDirectories mocks base method.
func (m *MockDirectoryReader) GetAllDirectories(ctx context.Context) (*[]Directory, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllDirectories", ctx)
        ret0, _ := ret[0].(*[]Directory)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllDirectories indicates an expected call of GetAllDirectories.
func (mr *MockDirectoryReaderMockRecorder) GetAllDirectories(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllDirectories", reflect.TypeOf((*MockDirectoryReader)(nil).GetAllDirectories), ctx)
}</span>

// GetDirectories mocks base method.
func (m *MockDirectoryReader) GetDirectories(ctx context.Context, conds ...any) (*[]Directory, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetDirectories", varargs...)
        ret0, _ := ret[0].(*[]Directory)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetDirectories indicates an expected call of GetDirectories.
func (mr *MockDirectoryReaderMockRecorder) GetDirectories(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDirectories", reflect.TypeOf((*MockDirectoryReader)(nil).GetDirectories), varargs...)
}</span>

// GetDirectory mocks base method.
func (m *MockDirectoryReader) GetDirectory(ctx context.Context, conds ...any) (*Directory, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetDirectory", varargs...)
        ret0, _ := ret[0].(*Directory)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetDirectory indicates an expected call of GetDirectory.
func (mr *MockDirectoryReaderMockRecorder) GetDirectory(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDirectory", reflect.TypeOf((*MockDirectoryReader)(nil).GetDirectory), varargs...)
}</span>

// MockDirectoryWriter is a mock of DirectoryWriter interface.
type MockDirectoryWriter struct {
        ctrl     *gomock.Controller
        recorder *MockDirectoryWriterMockRecorder
        isgomock struct{}
}

// MockDirectoryWriterMockRecorder is the mock recorder for MockDirectoryWriter.
type MockDirectoryWriterMockRecorder struct {
        mock *MockDirectoryWriter
}

// NewMockDirectoryWriter creates a new mock instance.
func NewMockDirectoryWriter(ctrl *gomock.Controller) *MockDirectoryWriter <span class="cov0" title="0">{
        mock := &amp;MockDirectoryWriter{ctrl: ctrl}
        mock.recorder = &amp;MockDirectoryWriterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDirectoryWriter) EXPECT() *MockDirectoryWriterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateOrUpdateDirectory mocks base method.
func (m *MockDirectoryWriter) CreateOrUpdateDirectory(ctx context.Context, directory *Directory) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateOrUpdateDirectory", ctx, directory)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateOrUpdateDirectory indicates an expected call of CreateOrUpdateDirectory.
func (mr *MockDirectoryWriterMockRecorder) CreateOrUpdateDirectory(ctx, directory any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrUpdateDirectory", reflect.TypeOf((*MockDirectoryWriter)(nil).CreateOrUpdateDirectory), ctx, directory)
}</span>

// RemoveDirectory mocks base method.
func (m *MockDirectoryWriter) RemoveDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveDirectory", ctx, path)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveDirectory indicates an expected call of RemoveDirectory.
func (mr *MockDirectoryWriterMockRecorder) RemoveDirectory(ctx, path any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveDirectory", reflect.TypeOf((*MockDirectoryWriter)(nil).RemoveDirectory), ctx, path)
}</span>

// RemoveTagFromDirectory mocks base method.
func (m *MockDirectoryWriter) RemoveTagFromDirectory(ctx context.Context, direcotryPath string, tagId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveTagFromDirectory", ctx, direcotryPath, tagId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveTagFromDirectory indicates an expected call of RemoveTagFromDirectory.
func (mr *MockDirectoryWriterMockRecorder) RemoveTagFromDirectory(ctx, direcotryPath, tagId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTagFromDirectory", reflect.TypeOf((*MockDirectoryWriter)(nil).RemoveTagFromDirectory), ctx, direcotryPath, tagId)
}</span>

// UpdateDirectory mocks base method.
func (m *MockDirectoryWriter) UpdateDirectory(ctx context.Context, directory *Directory) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateDirectory", ctx, directory)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateDirectory indicates an expected call of UpdateDirectory.
func (mr *MockDirectoryWriterMockRecorder) UpdateDirectory(ctx, directory any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateDirectory", reflect.TypeOf((*MockDirectoryWriter)(nil).UpdateDirectory), ctx, directory)
}</span>

// MockDirectoryReaderWriter is a mock of DirectoryReaderWriter interface.
type MockDirectoryReaderWriter struct {
        ctrl     *gomock.Controller
        recorder *MockDirectoryReaderWriterMockRecorder
        isgomock struct{}
}

// MockDirectoryReaderWriterMockRecorder is the mock recorder for MockDirectoryReaderWriter.
type MockDirectoryReaderWriterMockRecorder struct {
        mock *MockDirectoryReaderWriter
}

// NewMockDirectoryReaderWriter creates a new mock instance.
func NewMockDirectoryReaderWriter(ctrl *gomock.Controller) *MockDirectoryReaderWriter <span class="cov0" title="0">{
        mock := &amp;MockDirectoryReaderWriter{ctrl: ctrl}
        mock.recorder = &amp;MockDirectoryReaderWriterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDirectoryReaderWriter) EXPECT() *MockDirectoryReaderWriterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateOrUpdateDirectory mocks base method.
func (m *MockDirectoryReaderWriter) CreateOrUpdateDirectory(ctx context.Context, directory *Directory) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateOrUpdateDirectory", ctx, directory)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateOrUpdateDirectory indicates an expected call of CreateOrUpdateDirectory.
func (mr *MockDirectoryReaderWriterMockRecorder) CreateOrUpdateDirectory(ctx, directory any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrUpdateDirectory", reflect.TypeOf((*MockDirectoryReaderWriter)(nil).CreateOrUpdateDirectory), ctx, directory)
}</span>

// GetAllDirectories mocks base method.
func (m *MockDirectoryReaderWriter) GetAllDirectories(ctx context.Context) (*[]Directory, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllDirectories", ctx)
        ret0, _ := ret[0].(*[]Directory)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllDirectories indicates an expected call of GetAllDirectories.
func (mr *MockDirectoryReaderWriterMockRecorder) GetAllDirectories(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllDirectories", reflect.TypeOf((*MockDirectoryReaderWriter)(nil).GetAllDirectories), ctx)
}</span>

// GetDirectories mocks base method.
func (m *MockDirectoryReaderWriter) GetDirectories(ctx context.Context, conds ...any) (*[]Directory, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetDirectories", varargs...)
        ret0, _ := ret[0].(*[]Directory)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetDirectories indicates an expected call of GetDirectories.
func (mr *MockDirectoryReaderWriterMockRecorder) GetDirectories(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDirectories", reflect.TypeOf((*MockDirectoryReaderWriter)(nil).GetDirectories), varargs...)
}</span>

// GetDirectory mocks base method.
func (m *MockDirectoryReaderWriter) GetDirectory(ctx context.Context, conds ...any) (*Directory, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetDirectory", varargs...)
        ret0, _ := ret[0].(*Directory)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetDirectory indicates an expected call of GetDirectory.
func (mr *MockDirectoryReaderWriterMockRecorder) GetDirectory(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDirectory", reflect.TypeOf((*MockDirectoryReaderWriter)(nil).GetDirectory), varargs...)
}</span>

// RemoveDirectory mocks base method.
func (m *MockDirectoryReaderWriter) RemoveDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveDirectory", ctx, path)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveDirectory indicates an expected call of RemoveDirectory.
func (mr *MockDirectoryReaderWriterMockRecorder) RemoveDirectory(ctx, path any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveDirectory", reflect.TypeOf((*MockDirectoryReaderWriter)(nil).RemoveDirectory), ctx, path)
}</span>

// RemoveTagFromDirectory mocks base method.
func (m *MockDirectoryReaderWriter) RemoveTagFromDirectory(ctx context.Context, direcotryPath string, tagId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveTagFromDirectory", ctx, direcotryPath, tagId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveTagFromDirectory indicates an expected call of RemoveTagFromDirectory.
func (mr *MockDirectoryReaderWriterMockRecorder) RemoveTagFromDirectory(ctx, direcotryPath, tagId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTagFromDirectory", reflect.TypeOf((*MockDirectoryReaderWriter)(nil).RemoveTagFromDirectory), ctx, direcotryPath, tagId)
}</span>

// UpdateDirectory mocks base method.
func (m *MockDirectoryReaderWriter) UpdateDirectory(ctx context.Context, directory *Directory) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateDirectory", ctx, directory)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateDirectory indicates an expected call of UpdateDirectory.
func (mr *MockDirectoryReaderWriterMockRecorder) UpdateDirectory(ctx, directory any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateDirectory", reflect.TypeOf((*MockDirectoryReaderWriter)(nil).UpdateDirectory), ctx, directory)
}</span>

// MockTagImageTypeReader is a mock of TagImageTypeReader interface.
type MockTagImageTypeReader struct {
        ctrl     *gomock.Controller
        recorder *MockTagImageTypeReaderMockRecorder
        isgomock struct{}
}

// MockTagImageTypeReaderMockRecorder is the mock recorder for MockTagImageTypeReader.
type MockTagImageTypeReaderMockRecorder struct {
        mock *MockTagImageTypeReader
}

// NewMockTagImageTypeReader creates a new mock instance.
func NewMockTagImageTypeReader(ctrl *gomock.Controller) *MockTagImageTypeReader <span class="cov0" title="0">{
        mock := &amp;MockTagImageTypeReader{ctrl: ctrl}
        mock.recorder = &amp;MockTagImageTypeReaderMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTagImageTypeReader) EXPECT() *MockTagImageTypeReaderMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetAllTagImageTypes mocks base method.
func (m *MockTagImageTypeReader) GetAllTagImageTypes(ctx context.Context) (*[]TagImageType, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllTagImageTypes", ctx)
        ret0, _ := ret[0].(*[]TagImageType)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllTagImageTypes indicates an expected call of GetAllTagImageTypes.
func (mr *MockTagImageTypeReaderMockRecorder) GetAllTagImageTypes(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllTagImageTypes", reflect.TypeOf((*MockTagImageTypeReader)(nil).GetAllTagImageTypes), ctx)
}</span>

// GetTagImageType mocks base method.
func (m *MockTagImageTypeReader) GetTagImageType(ctx context.Context, conds ...any) (*TagImageType, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetTagImageType", varargs...)
        ret0, _ := ret[0].(*TagImageType)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetTagImageType indicates an expected call of GetTagImageType.
func (mr *MockTagImageTypeReaderMockRecorder) GetTagImageType(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTagImageType", reflect.TypeOf((*MockTagImageTypeReader)(nil).GetTagImageType), varargs...)
}</span>

// MockTagImageTypeWriter is a mock of TagImageTypeWriter interface.
type MockTagImageTypeWriter struct {
        ctrl     *gomock.Controller
        recorder *MockTagImageTypeWriterMockRecorder
        isgomock struct{}
}

// MockTagImageTypeWriterMockRecorder is the mock recorder for MockTagImageTypeWriter.
type MockTagImageTypeWriterMockRecorder struct {
        mock *MockTagImageTypeWriter
}

// NewMockTagImageTypeWriter creates a new mock instance.
func NewMockTagImageTypeWriter(ctrl *gomock.Controller) *MockTagImageTypeWriter <span class="cov0" title="0">{
        mock := &amp;MockTagImageTypeWriter{ctrl: ctrl}
        mock.recorder = &amp;MockTagImageTypeWriterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTagImageTypeWriter) EXPECT() *MockTagImageTypeWriterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateOrUpdateTagImageType mocks base method.
func (m *MockTagImageTypeWriter) CreateOrUpdateTagImageType(ctx context.Context, tit *TagImageType) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateOrUpdateTagImageType", ctx, tit)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateOrUpdateTagImageType indicates an expected call of CreateOrUpdateTagImageType.
func (mr *MockTagImageTypeWriterMockRecorder) CreateOrUpdateTagImageType(ctx, tit any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrUpdateTagImageType", reflect.TypeOf((*MockTagImageTypeWriter)(nil).CreateOrUpdateTagImageType), ctx, tit)
}</span>

// MockTagImageTypeReaderWriter is a mock of TagImageTypeReaderWriter interface.
type MockTagImageTypeReaderWriter struct {
        ctrl     *gomock.Controller
        recorder *MockTagImageTypeReaderWriterMockRecorder
        isgomock struct{}
}

// MockTagImageTypeReaderWriterMockRecorder is the mock recorder for MockTagImageTypeReaderWriter.
type MockTagImageTypeReaderWriterMockRecorder struct {
        mock *MockTagImageTypeReaderWriter
}

// NewMockTagImageTypeReaderWriter creates a new mock instance.
func NewMockTagImageTypeReaderWriter(ctrl *gomock.Controller) *MockTagImageTypeReaderWriter <span class="cov0" title="0">{
        mock := &amp;MockTagImageTypeReaderWriter{ctrl: ctrl}
        mock.recorder = &amp;MockTagImageTypeReaderWriterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTagImageTypeReaderWriter) EXPECT() *MockTagImageTypeReaderWriterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateOrUpdateTagImageType mocks base method.
func (m *MockTagImageTypeReaderWriter) CreateOrUpdateTagImageType(ctx context.Context, tit *TagImageType) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateOrUpdateTagImageType", ctx, tit)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateOrUpdateTagImageType indicates an expected call of CreateOrUpdateTagImageType.
func (mr *MockTagImageTypeReaderWriterMockRecorder) CreateOrUpdateTagImageType(ctx, tit any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrUpdateTagImageType", reflect.TypeOf((*MockTagImageTypeReaderWriter)(nil).CreateOrUpdateTagImageType), ctx, tit)
}</span>

// GetAllTagImageTypes mocks base method.
func (m *MockTagImageTypeReaderWriter) GetAllTagImageTypes(ctx context.Context) (*[]TagImageType, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllTagImageTypes", ctx)
        ret0, _ := ret[0].(*[]TagImageType)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllTagImageTypes indicates an expected call of GetAllTagImageTypes.
func (mr *MockTagImageTypeReaderWriterMockRecorder) GetAllTagImageTypes(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllTagImageTypes", reflect.TypeOf((*MockTagImageTypeReaderWriter)(nil).GetAllTagImageTypes), ctx)
}</span>

// GetTagImageType mocks base method.
func (m *MockTagImageTypeReaderWriter) GetTagImageType(ctx context.Context, conds ...any) (*TagImageType, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetTagImageType", varargs...)
        ret0, _ := ret[0].(*TagImageType)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetTagImageType indicates an expected call of GetTagImageType.
func (mr *MockTagImageTypeReaderWriterMockRecorder) GetTagImageType(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTagImageType", reflect.TypeOf((*MockTagImageTypeReaderWriter)(nil).GetTagImageType), varargs...)
}</span>

// MockTagImageWriter is a mock of TagImageWriter interface.
type MockTagImageWriter struct {
        ctrl     *gomock.Controller
        recorder *MockTagImageWriterMockRecorder
        isgomock struct{}
}

// MockTagImageWriterMockRecorder is the mock recorder for MockTagImageWriter.
type MockTagImageWriterMockRecorder struct {
        mock *MockTagImageWriter
}

// NewMockTagImageWriter creates a new mock instance.
func NewMockTagImageWriter(ctrl *gomock.Controller) *MockTagImageWriter <span class="cov0" title="0">{
        mock := &amp;MockTagImageWriter{ctrl: ctrl}
        mock.recorder = &amp;MockTagImageWriterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTagImageWriter) EXPECT() *MockTagImageWriterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// UpdateTagImage mocks base method.
func (m *MockTagImageWriter) UpdateTagImage(ctx context.Context, image *TagImage) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateTagImage", ctx, image)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateTagImage indicates an expected call of UpdateTagImage.
func (mr *MockTagImageWriterMockRecorder) UpdateTagImage(ctx, image any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTagImage", reflect.TypeOf((*MockTagImageWriter)(nil).UpdateTagImage), ctx, image)
}</span>

// MockStorageDownloader is a mock of StorageDownloader interface.
type MockStorageDownloader struct {
        ctrl     *gomock.Controller
        recorder *MockStorageDownloaderMockRecorder
        isgomock struct{}
}

// MockStorageDownloaderMockRecorder is the mock recorder for MockStorageDownloader.
type MockStorageDownloaderMockRecorder struct {
        mock *MockStorageDownloader
}

// NewMockStorageDownloader creates a new mock instance.
func NewMockStorageDownloader(ctrl *gomock.Controller) *MockStorageDownloader <span class="cov0" title="0">{
        mock := &amp;MockStorageDownloader{ctrl: ctrl}
        mock.recorder = &amp;MockStorageDownloaderMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStorageDownloader) EXPECT() *MockStorageDownloaderMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetFile mocks base method.
func (m *MockStorageDownloader) GetFile(name string) string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetFile", name)
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// GetFile indicates an expected call of GetFile.
func (mr *MockStorageDownloaderMockRecorder) GetFile(name any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFile", reflect.TypeOf((*MockStorageDownloader)(nil).GetFile), name)
}</span>

// IsStorageUrl mocks base method.
func (m *MockStorageDownloader) IsStorageUrl(name string) bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsStorageUrl", name)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsStorageUrl indicates an expected call of IsStorageUrl.
func (mr *MockStorageDownloaderMockRecorder) IsStorageUrl(name any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsStorageUrl", reflect.TypeOf((*MockStorageDownloader)(nil).IsStorageUrl), name)
}</span>

// MockStorageUploader is a mock of StorageUploader interface.
type MockStorageUploader struct {
        ctrl     *gomock.Controller
        recorder *MockStorageUploaderMockRecorder
        isgomock struct{}
}

// MockStorageUploaderMockRecorder is the mock recorder for MockStorageUploader.
type MockStorageUploaderMockRecorder struct {
        mock *MockStorageUploader
}

// NewMockStorageUploader creates a new mock instance.
func NewMockStorageUploader(ctrl *gomock.Controller) *MockStorageUploader <span class="cov0" title="0">{
        mock := &amp;MockStorageUploader{ctrl: ctrl}
        mock.recorder = &amp;MockStorageUploaderMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStorageUploader) EXPECT() *MockStorageUploaderMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetFileForWriting mocks base method.
func (m *MockStorageUploader) GetFileForWriting(name string) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetFileForWriting", name)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetFileForWriting indicates an expected call of GetFileForWriting.
func (mr *MockStorageUploaderMockRecorder) GetFileForWriting(name any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFileForWriting", reflect.TypeOf((*MockStorageUploader)(nil).GetFileForWriting), name)
}</span>

// GetStorageUrl mocks base method.
func (m *MockStorageUploader) GetStorageUrl(name string) string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetStorageUrl", name)
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// GetStorageUrl indicates an expected call of GetStorageUrl.
func (mr *MockStorageUploaderMockRecorder) GetStorageUrl(name any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStorageUrl", reflect.TypeOf((*MockStorageUploader)(nil).GetStorageUrl), name)
}</span>

// GetTempFile mocks base method.
func (m *MockStorageUploader) GetTempFile() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTempFile")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// GetTempFile indicates an expected call of GetTempFile.
func (mr *MockStorageUploaderMockRecorder) GetTempFile() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTempFile", reflect.TypeOf((*MockStorageUploader)(nil).GetTempFile))
}</span>

// MockTempFileProvider is a mock of TempFileProvider interface.
type MockTempFileProvider struct {
        ctrl     *gomock.Controller
        recorder *MockTempFileProviderMockRecorder
        isgomock struct{}
}

// MockTempFileProviderMockRecorder is the mock recorder for MockTempFileProvider.
type MockTempFileProviderMockRecorder struct {
        mock *MockTempFileProvider
}

// NewMockTempFileProvider creates a new mock instance.
func NewMockTempFileProvider(ctrl *gomock.Controller) *MockTempFileProvider <span class="cov0" title="0">{
        mock := &amp;MockTempFileProvider{ctrl: ctrl}
        mock.recorder = &amp;MockTempFileProviderMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTempFileProvider) EXPECT() *MockTempFileProviderMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetTempFile mocks base method.
func (m *MockTempFileProvider) GetTempFile() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTempFile")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// GetTempFile indicates an expected call of GetTempFile.
func (mr *MockTempFileProviderMockRecorder) GetTempFile() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTempFile", reflect.TypeOf((*MockTempFileProvider)(nil).GetTempFile))
}</span>

// MockDirectoryItemsGetter is a mock of DirectoryItemsGetter interface.
type MockDirectoryItemsGetter struct {
        ctrl     *gomock.Controller
        recorder *MockDirectoryItemsGetterMockRecorder
        isgomock struct{}
}

// MockDirectoryItemsGetterMockRecorder is the mock recorder for MockDirectoryItemsGetter.
type MockDirectoryItemsGetterMockRecorder struct {
        mock *MockDirectoryItemsGetter
}

// NewMockDirectoryItemsGetter creates a new mock instance.
func NewMockDirectoryItemsGetter(ctrl *gomock.Controller) *MockDirectoryItemsGetter <span class="cov0" title="0">{
        mock := &amp;MockDirectoryItemsGetter{ctrl: ctrl}
        mock.recorder = &amp;MockDirectoryItemsGetterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDirectoryItemsGetter) EXPECT() *MockDirectoryItemsGetterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetBelongingItem mocks base method.
func (m *MockDirectoryItemsGetter) GetBelongingItem(ctx context.Context, path, filename string) (*Item, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetBelongingItem", ctx, path, filename)
        ret0, _ := ret[0].(*Item)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetBelongingItem indicates an expected call of GetBelongingItem.
func (mr *MockDirectoryItemsGetterMockRecorder) GetBelongingItem(ctx, path, filename any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBelongingItem", reflect.TypeOf((*MockDirectoryItemsGetter)(nil).GetBelongingItem), ctx, path, filename)
}</span>

// GetBelongingItems mocks base method.
func (m *MockDirectoryItemsGetter) GetBelongingItems(ctx context.Context, path string) (*[]Item, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetBelongingItems", ctx, path)
        ret0, _ := ret[0].(*[]Item)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetBelongingItems indicates an expected call of GetBelongingItems.
func (mr *MockDirectoryItemsGetterMockRecorder) GetBelongingItems(ctx, path any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBelongingItems", reflect.TypeOf((*MockDirectoryItemsGetter)(nil).GetBelongingItems), ctx, path)
}</span>

// MockDirectoryItemsSetter is a mock of DirectoryItemsSetter interface.
type MockDirectoryItemsSetter struct {
        ctrl     *gomock.Controller
        recorder *MockDirectoryItemsSetterMockRecorder
        isgomock struct{}
}

// MockDirectoryItemsSetterMockRecorder is the mock recorder for MockDirectoryItemsSetter.
type MockDirectoryItemsSetterMockRecorder struct {
        mock *MockDirectoryItemsSetter
}

// NewMockDirectoryItemsSetter creates a new mock instance.
func NewMockDirectoryItemsSetter(ctrl *gomock.Controller) *MockDirectoryItemsSetter <span class="cov0" title="0">{
        mock := &amp;MockDirectoryItemsSetter{ctrl: ctrl}
        mock.recorder = &amp;MockDirectoryItemsSetterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDirectoryItemsSetter) EXPECT() *MockDirectoryItemsSetterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AddBelongingItem mocks base method.
func (m *MockDirectoryItemsSetter) AddBelongingItem(ctx context.Context, item *Item) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddBelongingItem", ctx, item)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AddBelongingItem indicates an expected call of AddBelongingItem.
func (mr *MockDirectoryItemsSetterMockRecorder) AddBelongingItem(ctx, item any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddBelongingItem", reflect.TypeOf((*MockDirectoryItemsSetter)(nil).AddBelongingItem), ctx, item)
}</span>

// MockDirectoryItemsGetterSetter is a mock of DirectoryItemsGetterSetter interface.
type MockDirectoryItemsGetterSetter struct {
        ctrl     *gomock.Controller
        recorder *MockDirectoryItemsGetterSetterMockRecorder
        isgomock struct{}
}

// MockDirectoryItemsGetterSetterMockRecorder is the mock recorder for MockDirectoryItemsGetterSetter.
type MockDirectoryItemsGetterSetterMockRecorder struct {
        mock *MockDirectoryItemsGetterSetter
}

// NewMockDirectoryItemsGetterSetter creates a new mock instance.
func NewMockDirectoryItemsGetterSetter(ctrl *gomock.Controller) *MockDirectoryItemsGetterSetter <span class="cov0" title="0">{
        mock := &amp;MockDirectoryItemsGetterSetter{ctrl: ctrl}
        mock.recorder = &amp;MockDirectoryItemsGetterSetterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDirectoryItemsGetterSetter) EXPECT() *MockDirectoryItemsGetterSetterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AddBelongingItem mocks base method.
func (m *MockDirectoryItemsGetterSetter) AddBelongingItem(ctx context.Context, item *Item) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AddBelongingItem", ctx, item)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AddBelongingItem indicates an expected call of AddBelongingItem.
func (mr *MockDirectoryItemsGetterSetterMockRecorder) AddBelongingItem(ctx, item any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddBelongingItem", reflect.TypeOf((*MockDirectoryItemsGetterSetter)(nil).AddBelongingItem), ctx, item)
}</span>

// GetBelongingItem mocks base method.
func (m *MockDirectoryItemsGetterSetter) GetBelongingItem(ctx context.Context, path, filename string) (*Item, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetBelongingItem", ctx, path, filename)
        ret0, _ := ret[0].(*Item)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetBelongingItem indicates an expected call of GetBelongingItem.
func (mr *MockDirectoryItemsGetterSetterMockRecorder) GetBelongingItem(ctx, path, filename any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBelongingItem", reflect.TypeOf((*MockDirectoryItemsGetterSetter)(nil).GetBelongingItem), ctx, path, filename)
}</span>

// GetBelongingItems mocks base method.
func (m *MockDirectoryItemsGetterSetter) GetBelongingItems(ctx context.Context, path string) (*[]Item, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetBelongingItems", ctx, path)
        ret0, _ := ret[0].(*[]Item)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetBelongingItems indicates an expected call of GetBelongingItems.
func (mr *MockDirectoryItemsGetterSetterMockRecorder) GetBelongingItems(ctx, path any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBelongingItems", reflect.TypeOf((*MockDirectoryItemsGetterSetter)(nil).GetBelongingItems), ctx, path)
}</span>

// MockTaskReader is a mock of TaskReader interface.
type MockTaskReader struct {
        ctrl     *gomock.Controller
        recorder *MockTaskReaderMockRecorder
        isgomock struct{}
}

// MockTaskReaderMockRecorder is the mock recorder for MockTaskReader.
type MockTaskReaderMockRecorder struct {
        mock *MockTaskReader
}

// NewMockTaskReader creates a new mock instance.
func NewMockTaskReader(ctrl *gomock.Controller) *MockTaskReader <span class="cov0" title="0">{
        mock := &amp;MockTaskReader{ctrl: ctrl}
        mock.recorder = &amp;MockTaskReaderMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTaskReader) EXPECT() *MockTaskReaderMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetTasks mocks base method.
func (m *MockTaskReader) GetTasks(ctx context.Context, offset, limit int) (*[]Task, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTasks", ctx, offset, limit)
        ret0, _ := ret[0].(*[]Task)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTasks indicates an expected call of GetTasks.
func (mr *MockTaskReaderMockRecorder) GetTasks(ctx, offset, limit any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTasks", reflect.TypeOf((*MockTaskReader)(nil).GetTasks), ctx, offset, limit)
}</span>

// TasksCount mocks base method.
func (m *MockTaskReader) TasksCount(ctx context.Context, query any, conds ...any) (int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx, query}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "TasksCount", varargs...)
        ret0, _ := ret[0].(int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// TasksCount indicates an expected call of TasksCount.
func (mr *MockTaskReaderMockRecorder) TasksCount(ctx, query any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx, query}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TasksCount", reflect.TypeOf((*MockTaskReader)(nil).TasksCount), varargs...)
}</span>

// MockProcessorStatus is a mock of ProcessorStatus interface.
type MockProcessorStatus struct {
        ctrl     *gomock.Controller
        recorder *MockProcessorStatusMockRecorder
        isgomock struct{}
}

// MockProcessorStatusMockRecorder is the mock recorder for MockProcessorStatus.
type MockProcessorStatusMockRecorder struct {
        mock *MockProcessorStatus
}

// NewMockProcessorStatus creates a new mock instance.
func NewMockProcessorStatus(ctrl *gomock.Controller) *MockProcessorStatus <span class="cov0" title="0">{
        mock := &amp;MockProcessorStatus{ctrl: ctrl}
        mock.recorder = &amp;MockProcessorStatusMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProcessorStatus) EXPECT() *MockProcessorStatusMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// IsPaused mocks base method.
func (m *MockProcessorStatus) IsPaused() bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsPaused")
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsPaused indicates an expected call of IsPaused.
func (mr *MockProcessorStatusMockRecorder) IsPaused() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsPaused", reflect.TypeOf((*MockProcessorStatus)(nil).IsPaused))
}</span>

// MockDirectoryAutoTagsGetter is a mock of DirectoryAutoTagsGetter interface.
type MockDirectoryAutoTagsGetter struct {
        ctrl     *gomock.Controller
        recorder *MockDirectoryAutoTagsGetterMockRecorder
        isgomock struct{}
}

// MockDirectoryAutoTagsGetterMockRecorder is the mock recorder for MockDirectoryAutoTagsGetter.
type MockDirectoryAutoTagsGetterMockRecorder struct {
        mock *MockDirectoryAutoTagsGetter
}

// NewMockDirectoryAutoTagsGetter creates a new mock instance.
func NewMockDirectoryAutoTagsGetter(ctrl *gomock.Controller) *MockDirectoryAutoTagsGetter <span class="cov0" title="0">{
        mock := &amp;MockDirectoryAutoTagsGetter{ctrl: ctrl}
        mock.recorder = &amp;MockDirectoryAutoTagsGetterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDirectoryAutoTagsGetter) EXPECT() *MockDirectoryAutoTagsGetterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetAutoTags mocks base method.
func (m *MockDirectoryAutoTagsGetter) GetAutoTags(ctx context.Context, path string) ([]*Tag, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAutoTags", ctx, path)
        ret0, _ := ret[0].([]*Tag)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAutoTags indicates an expected call of GetAutoTags.
func (mr *MockDirectoryAutoTagsGetterMockRecorder) GetAutoTags(ctx, path any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAutoTags", reflect.TypeOf((*MockDirectoryAutoTagsGetter)(nil).GetAutoTags), ctx, path)
}</span>

// MockFileMetadataGetter is a mock of FileMetadataGetter interface.
type MockFileMetadataGetter struct {
        ctrl     *gomock.Controller
        recorder *MockFileMetadataGetterMockRecorder
        isgomock struct{}
}

// MockFileMetadataGetterMockRecorder is the mock recorder for MockFileMetadataGetter.
type MockFileMetadataGetterMockRecorder struct {
        mock *MockFileMetadataGetter
}

// NewMockFileMetadataGetter creates a new mock instance.
func NewMockFileMetadataGetter(ctrl *gomock.Controller) *MockFileMetadataGetter <span class="cov0" title="0">{
        mock := &amp;MockFileMetadataGetter{ctrl: ctrl}
        mock.recorder = &amp;MockFileMetadataGetterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFileMetadataGetter) EXPECT() *MockFileMetadataGetterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetFileMetadata mocks base method.
func (m *MockFileMetadataGetter) GetFileMetadata(f string) (int64, int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetFileMetadata", f)
        ret0, _ := ret[0].(int64)
        ret1, _ := ret[1].(int64)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// GetFileMetadata indicates an expected call of GetFileMetadata.
func (mr *MockFileMetadataGetterMockRecorder) GetFileMetadata(f any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFileMetadata", reflect.TypeOf((*MockFileMetadataGetter)(nil).GetFileMetadata), f)
}</span>

// MockCurrentTimeGetter is a mock of CurrentTimeGetter interface.
type MockCurrentTimeGetter struct {
        ctrl     *gomock.Controller
        recorder *MockCurrentTimeGetterMockRecorder
        isgomock struct{}
}

// MockCurrentTimeGetterMockRecorder is the mock recorder for MockCurrentTimeGetter.
type MockCurrentTimeGetterMockRecorder struct {
        mock *MockCurrentTimeGetter
}

// NewMockCurrentTimeGetter creates a new mock instance.
func NewMockCurrentTimeGetter(ctrl *gomock.Controller) *MockCurrentTimeGetter <span class="cov0" title="0">{
        mock := &amp;MockCurrentTimeGetter{ctrl: ctrl}
        mock.recorder = &amp;MockCurrentTimeGetterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCurrentTimeGetter) EXPECT() *MockCurrentTimeGetterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetCurrentTime mocks base method.
func (m *MockCurrentTimeGetter) GetCurrentTime() time.Time <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCurrentTime")
        ret0, _ := ret[0].(time.Time)
        return ret0
}</span>

// GetCurrentTime indicates an expected call of GetCurrentTime.
func (mr *MockCurrentTimeGetterMockRecorder) GetCurrentTime() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCurrentTime", reflect.TypeOf((*MockCurrentTimeGetter)(nil).GetCurrentTime))
}</span>

// MockDatabase is a mock of Database interface.
type MockDatabase struct {
        ctrl     *gomock.Controller
        recorder *MockDatabaseMockRecorder
        isgomock struct{}
}

// MockDatabaseMockRecorder is the mock recorder for MockDatabase.
type MockDatabaseMockRecorder struct {
        mock *MockDatabase
}

// NewMockDatabase creates a new mock instance.
func NewMockDatabase(ctrl *gomock.Controller) *MockDatabase <span class="cov0" title="0">{
        mock := &amp;MockDatabase{ctrl: ctrl}
        mock.recorder = &amp;MockDatabaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDatabase) EXPECT() *MockDatabaseMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateOrUpdateDirectory mocks base method.
func (m *MockDatabase) CreateOrUpdateDirectory(ctx context.Context, directory *Directory) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateOrUpdateDirectory", ctx, directory)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateOrUpdateDirectory indicates an expected call of CreateOrUpdateDirectory.
func (mr *MockDatabaseMockRecorder) CreateOrUpdateDirectory(ctx, directory any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrUpdateDirectory", reflect.TypeOf((*MockDatabase)(nil).CreateOrUpdateDirectory), ctx, directory)
}</span>

// CreateOrUpdateItem mocks base method.
func (m *MockDatabase) CreateOrUpdateItem(ctx context.Context, item *Item) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateOrUpdateItem", ctx, item)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateOrUpdateItem indicates an expected call of CreateOrUpdateItem.
func (mr *MockDatabaseMockRecorder) CreateOrUpdateItem(ctx, item any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrUpdateItem", reflect.TypeOf((*MockDatabase)(nil).CreateOrUpdateItem), ctx, item)
}</span>

// CreateOrUpdateTag mocks base method.
func (m *MockDatabase) CreateOrUpdateTag(ctx context.Context, tag *Tag) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateOrUpdateTag", ctx, tag)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateOrUpdateTag indicates an expected call of CreateOrUpdateTag.
func (mr *MockDatabaseMockRecorder) CreateOrUpdateTag(ctx, tag any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrUpdateTag", reflect.TypeOf((*MockDatabase)(nil).CreateOrUpdateTag), ctx, tag)
}</span>

// GetAllDirectories mocks base method.
func (m *MockDatabase) GetAllDirectories(ctx context.Context) (*[]Directory, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllDirectories", ctx)
        ret0, _ := ret[0].(*[]Directory)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllDirectories indicates an expected call of GetAllDirectories.
func (mr *MockDatabaseMockRecorder) GetAllDirectories(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllDirectories", reflect.TypeOf((*MockDatabase)(nil).GetAllDirectories), ctx)
}</span>

// GetAllItems mocks base method.
func (m *MockDatabase) GetAllItems(ctx context.Context) (*[]Item, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllItems", ctx)
        ret0, _ := ret[0].(*[]Item)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllItems indicates an expected call of GetAllItems.
func (mr *MockDatabaseMockRecorder) GetAllItems(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllItems", reflect.TypeOf((*MockDatabase)(nil).GetAllItems), ctx)
}</span>

// GetAllTags mocks base method.
func (m *MockDatabase) GetAllTags(ctx context.Context) (*[]Tag, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllTags", ctx)
        ret0, _ := ret[0].(*[]Tag)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllTags indicates an expected call of GetAllTags.
func (mr *MockDatabaseMockRecorder) GetAllTags(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllTags", reflect.TypeOf((*MockDatabase)(nil).GetAllTags), ctx)
}</span>

// GetDirectories mocks base method.
func (m *MockDatabase) GetDirectories(ctx context.Context, conds ...any) (*[]Directory, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetDirectories", varargs...)
        ret0, _ := ret[0].(*[]Directory)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetDirectories indicates an expected call of GetDirectories.
func (mr *MockDatabaseMockRecorder) GetDirectories(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDirectories", reflect.TypeOf((*MockDatabase)(nil).GetDirectories), varargs...)
}</span>

// GetDirectory mocks base method.
func (m *MockDatabase) GetDirectory(ctx context.Context, conds ...any) (*Directory, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetDirectory", varargs...)
        ret0, _ := ret[0].(*Directory)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetDirectory indicates an expected call of GetDirectory.
func (mr *MockDatabaseMockRecorder) GetDirectory(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDirectory", reflect.TypeOf((*MockDatabase)(nil).GetDirectory), varargs...)
}</span>

// GetItem mocks base method.
func (m *MockDatabase) GetItem(ctx context.Context, conds ...any) (*Item, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetItem", varargs...)
        ret0, _ := ret[0].(*Item)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetItem indicates an expected call of GetItem.
func (mr *MockDatabaseMockRecorder) GetItem(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItem", reflect.TypeOf((*MockDatabase)(nil).GetItem), varargs...)
}</span>

// GetItems mocks base method.
func (m *MockDatabase) GetItems(ctx context.Context, conds ...any) (*[]Item, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetItems", varargs...)
        ret0, _ := ret[0].(*[]Item)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetItems indicates an expected call of GetItems.
func (mr *MockDatabaseMockRecorder) GetItems(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItems", reflect.TypeOf((*MockDatabase)(nil).GetItems), varargs...)
}</span>

// GetTag mocks base method.
func (m *MockDatabase) GetTag(ctx context.Context, conds ...any) (*Tag, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetTag", varargs...)
        ret0, _ := ret[0].(*Tag)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetTag indicates an expected call of GetTag.
func (mr *MockDatabaseMockRecorder) GetTag(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTag", reflect.TypeOf((*MockDatabase)(nil).GetTag), varargs...)
}</span>

// GetTags mocks base method.
func (m *MockDatabase) GetTags(ctx context.Context, conds ...any) (*[]Tag, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetTags", varargs...)
        ret0, _ := ret[0].(*[]Tag)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetTags indicates an expected call of GetTags.
func (mr *MockDatabaseMockRecorder) GetTags(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTags", reflect.TypeOf((*MockDatabase)(nil).GetTags), varargs...)
}</span>

// GetTagsWithoutChildren mocks base method.
func (m *MockDatabase) GetTagsWithoutChildren(ctx context.Context, conds ...any) (*[]Tag, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetTagsWithoutChildren", varargs...)
        ret0, _ := ret[0].(*[]Tag)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetTagsWithoutChildren indicates an expected call of GetTagsWithoutChildren.
func (mr *MockDatabaseMockRecorder) GetTagsWithoutChildren(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTagsWithoutChildren", reflect.TypeOf((*MockDatabase)(nil).GetTagsWithoutChildren), varargs...)
}</span>

// RemoveDirectory mocks base method.
func (m *MockDatabase) RemoveDirectory(ctx context.Context, path string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveDirectory", ctx, path)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveDirectory indicates an expected call of RemoveDirectory.
func (mr *MockDatabaseMockRecorder) RemoveDirectory(ctx, path any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveDirectory", reflect.TypeOf((*MockDatabase)(nil).RemoveDirectory), ctx, path)
}</span>

// RemoveItem mocks base method.
func (m *MockDatabase) RemoveItem(ctx context.Context, itemId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveItem", ctx, itemId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveItem indicates an expected call of RemoveItem.
func (mr *MockDatabaseMockRecorder) RemoveItem(ctx, itemId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveItem", reflect.TypeOf((*MockDatabase)(nil).RemoveItem), ctx, itemId)
}</span>

// RemoveTag mocks base method.
func (m *MockDatabase) RemoveTag(ctx context.Context, tagId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveTag", ctx, tagId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveTag indicates an expected call of RemoveTag.
func (mr *MockDatabaseMockRecorder) RemoveTag(ctx, tagId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTag", reflect.TypeOf((*MockDatabase)(nil).RemoveTag), ctx, tagId)
}</span>

// RemoveTagFromDirectory mocks base method.
func (m *MockDatabase) RemoveTagFromDirectory(ctx context.Context, direcotryPath string, tagId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveTagFromDirectory", ctx, direcotryPath, tagId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveTagFromDirectory indicates an expected call of RemoveTagFromDirectory.
func (mr *MockDatabaseMockRecorder) RemoveTagFromDirectory(ctx, direcotryPath, tagId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTagFromDirectory", reflect.TypeOf((*MockDatabase)(nil).RemoveTagFromDirectory), ctx, direcotryPath, tagId)
}</span>

// RemoveTagFromItem mocks base method.
func (m *MockDatabase) RemoveTagFromItem(ctx context.Context, itemId, tagId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveTagFromItem", ctx, itemId, tagId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveTagFromItem indicates an expected call of RemoveTagFromItem.
func (mr *MockDatabaseMockRecorder) RemoveTagFromItem(ctx, itemId, tagId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTagFromItem", reflect.TypeOf((*MockDatabase)(nil).RemoveTagFromItem), ctx, itemId, tagId)
}</span>

// RemoveTagImageFromTag mocks base method.
func (m *MockDatabase) RemoveTagImageFromTag(ctx context.Context, tagId, imageId uint64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveTagImageFromTag", ctx, tagId, imageId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveTagImageFromTag indicates an expected call of RemoveTagImageFromTag.
func (mr *MockDatabaseMockRecorder) RemoveTagImageFromTag(ctx, tagId, imageId any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTagImageFromTag", reflect.TypeOf((*MockDatabase)(nil).RemoveTagImageFromTag), ctx, tagId, imageId)
}</span>

// UpdateDirectory mocks base method.
func (m *MockDatabase) UpdateDirectory(ctx context.Context, directory *Directory) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateDirectory", ctx, directory)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateDirectory indicates an expected call of UpdateDirectory.
func (mr *MockDatabaseMockRecorder) UpdateDirectory(ctx, directory any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateDirectory", reflect.TypeOf((*MockDatabase)(nil).UpdateDirectory), ctx, directory)
}</span>

// UpdateItem mocks base method.
func (m *MockDatabase) UpdateItem(ctx context.Context, item *Item) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateItem", ctx, item)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateItem indicates an expected call of UpdateItem.
func (mr *MockDatabaseMockRecorder) UpdateItem(ctx, item any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateItem", reflect.TypeOf((*MockDatabase)(nil).UpdateItem), ctx, item)
}</span>

// UpdateTag mocks base method.
func (m *MockDatabase) UpdateTag(ctx context.Context, tag *Tag) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateTag", ctx, tag)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateTag indicates an expected call of UpdateTag.
func (mr *MockDatabaseMockRecorder) UpdateTag(ctx, tag any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTag", reflect.TypeOf((*MockDatabase)(nil).UpdateTag), ctx, tag)
}</span>

// MockTagCustomCommandsReader is a mock of TagCustomCommandsReader interface.
type MockTagCustomCommandsReader struct {
        ctrl     *gomock.Controller
        recorder *MockTagCustomCommandsReaderMockRecorder
        isgomock struct{}
}

// MockTagCustomCommandsReaderMockRecorder is the mock recorder for MockTagCustomCommandsReader.
type MockTagCustomCommandsReaderMockRecorder struct {
        mock *MockTagCustomCommandsReader
}

// NewMockTagCustomCommandsReader creates a new mock instance.
func NewMockTagCustomCommandsReader(ctrl *gomock.Controller) *MockTagCustomCommandsReader <span class="cov0" title="0">{
        mock := &amp;MockTagCustomCommandsReader{ctrl: ctrl}
        mock.recorder = &amp;MockTagCustomCommandsReaderMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTagCustomCommandsReader) EXPECT() *MockTagCustomCommandsReaderMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetAllTagCustomCommands mocks base method.
func (m *MockTagCustomCommandsReader) GetAllTagCustomCommands(ctx context.Context) (*[]TagCustomCommand, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAllTagCustomCommands", ctx)
        ret0, _ := ret[0].(*[]TagCustomCommand)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAllTagCustomCommands indicates an expected call of GetAllTagCustomCommands.
func (mr *MockTagCustomCommandsReaderMockRecorder) GetAllTagCustomCommands(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllTagCustomCommands", reflect.TypeOf((*MockTagCustomCommandsReader)(nil).GetAllTagCustomCommands), ctx)
}</span>

// GetTagCustomCommand mocks base method.
func (m *MockTagCustomCommandsReader) GetTagCustomCommand(ctx context.Context, conds ...any) (*[]TagCustomCommand, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []any{ctx}
        for _, a := range conds </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetTagCustomCommand", varargs...)
        ret0, _ := ret[0].(*[]TagCustomCommand)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetTagCustomCommand indicates an expected call of GetTagCustomCommand.
func (mr *MockTagCustomCommandsReaderMockRecorder) GetTagCustomCommand(ctx any, conds ...any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]any{ctx}, conds...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTagCustomCommand", reflect.TypeOf((*MockTagCustomCommandsReader)(nil).GetTagCustomCommand), varargs...)
}</span>

// MockDbMetadataReader is a mock of DbMetadataReader interface.
type MockDbMetadataReader struct {
        ctrl     *gomock.Controller
        recorder *MockDbMetadataReaderMockRecorder
        isgomock struct{}
}

// MockDbMetadataReaderMockRecorder is the mock recorder for MockDbMetadataReader.
type MockDbMetadataReaderMockRecorder struct {
        mock *MockDbMetadataReader
}

// NewMockDbMetadataReader creates a new mock instance.
func NewMockDbMetadataReader(ctrl *gomock.Controller) *MockDbMetadataReader <span class="cov0" title="0">{
        mock := &amp;MockDbMetadataReader{ctrl: ctrl}
        mock.recorder = &amp;MockDbMetadataReaderMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDbMetadataReader) EXPECT() *MockDbMetadataReaderMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetItemsCount mocks base method.
func (m *MockDbMetadataReader) GetItemsCount(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetItemsCount", ctx)
        ret0, _ := ret[0].(int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetItemsCount indicates an expected call of GetItemsCount.
func (mr *MockDbMetadataReaderMockRecorder) GetItemsCount(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetItemsCount", reflect.TypeOf((*MockDbMetadataReader)(nil).GetItemsCount), ctx)
}</span>

// GetTagsCount mocks base method.
func (m *MockDbMetadataReader) GetTagsCount(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTagsCount", ctx)
        ret0, _ := ret[0].(int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTagsCount indicates an expected call of GetTagsCount.
func (mr *MockDbMetadataReaderMockRecorder) GetTagsCount(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTagsCount", reflect.TypeOf((*MockDbMetadataReader)(nil).GetTagsCount), ctx)
}</span>

// GetTotalDurationSeconds mocks base method.
func (m *MockDbMetadataReader) GetTotalDurationSeconds(ctx context.Context) (float64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetTotalDurationSeconds", ctx)
        ret0, _ := ret[0].(float64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetTotalDurationSeconds indicates an expected call of GetTotalDurationSeconds.
func (mr *MockDbMetadataReaderMockRecorder) GetTotalDurationSeconds(ctx any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTotalDurationSeconds", reflect.TypeOf((*MockDbMetadataReader)(nil).GetTotalDurationSeconds), ctx)
}</span>

// MockPushListener is a mock of PushListener interface.
type MockPushListener struct {
        ctrl     *gomock.Controller
        recorder *MockPushListenerMockRecorder
        isgomock struct{}
}

// MockPushListenerMockRecorder is the mock recorder for MockPushListener.
type MockPushListenerMockRecorder struct {
        mock *MockPushListener
}

// NewMockPushListener creates a new mock instance.
func NewMockPushListener(ctrl *gomock.Controller) *MockPushListener <span class="cov0" title="0">{
        mock := &amp;MockPushListener{ctrl: ctrl}
        mock.recorder = &amp;MockPushListenerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPushListener) EXPECT() *MockPushListenerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Push mocks base method.
func (m_2 *MockPushListener) Push(m PushMessage) <span class="cov0" title="0">{
        m_2.ctrl.T.Helper()
        m_2.ctrl.Call(m_2, "Push", m)
}</span>

// Push indicates an expected call of Push.
func (mr *MockPushListenerMockRecorder) Push(m any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Push", reflect.TypeOf((*MockPushListener)(nil).Push), m)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package model

import (
        "database/sql/driver"
        "encoding/json"
        "fmt"

        "github.com/go-errors/errors"
)

const ROOT_DIRECTORY_PATH = "&lt;root&gt;"

type FsNodeType int

const (
        FS_NODE_DIR = iota + 1
        FS_NODE_FILE
)

type TaskType int

const (
        REFRESH_COVER_TASK = iota
        REFRESH_PREVIEW_TASK
        REFRESH_METADATA_TASK
        REFRESH_FILE_TASK
        SET_MAIN_COVER
        CROP_FRAME
        CHANGE_RESOLUTION
)

func (t TaskType) ToDescription(title string) string <span class="cov0" title="0">{
        switch t </span>{
        case REFRESH_COVER_TASK:<span class="cov0" title="0">
                return fmt.Sprintf("Extracting covers for %s", title)</span>
        case REFRESH_PREVIEW_TASK:<span class="cov0" title="0">
                return fmt.Sprintf("Generating preview for %s", title)</span>
        case REFRESH_METADATA_TASK:<span class="cov0" title="0">
                return fmt.Sprintf("Reading metadata for %s", title)</span>
        case REFRESH_FILE_TASK:<span class="cov0" title="0">
                return fmt.Sprintf("Reading file metadata for %s", title)</span>
        case SET_MAIN_COVER:<span class="cov0" title="0">
                return fmt.Sprintf("Setting main cover for %s", title)</span>
        case CHANGE_RESOLUTION:<span class="cov0" title="0">
                return fmt.Sprintf("Changing resolution %s", title)</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

func (t TaskType) String() string <span class="cov0" title="0">{
        switch t </span>{
        case REFRESH_COVER_TASK:<span class="cov0" title="0">
                return "cover"</span>
        case REFRESH_PREVIEW_TASK:<span class="cov0" title="0">
                return "preview"</span>
        case REFRESH_METADATA_TASK:<span class="cov0" title="0">
                return "metadata"</span>
        case REFRESH_FILE_TASK:<span class="cov0" title="0">
                return "file-metadata"</span>
        case SET_MAIN_COVER:<span class="cov0" title="0">
                return "main-cover"</span>
        case CHANGE_RESOLUTION:<span class="cov0" title="0">
                return "change-resolution"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

type PushMessageType int

const (
        // values in ws.js
        PUSH_PING           = 1
        PUSH_QUEUE_METADATA = 2
        PUSH_FS_CHANGE      = 3
)

type Rect struct {
        X int `json:"x"`
        Y int `json:"y"`
        H int `json:"height"`
        W int `json:"width"`
}

func (t Rect) Value() (driver.Value, error) <span class="cov8" title="1">{
        return json.Marshal(t)
}</span>

func (t *Rect) Scan(value interface{}) error <span class="cov0" title="0">{
        b, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return errors.Errorf("type assertion to []byte failed %v", value)
        }</span>

        <span class="cov0" title="0">return json.Unmarshal(b, &amp;t)</span>
}

type RectFloat struct {
        X float64 `json:"x"`
        Y float64 `json:"y"`
        H float64 `json:"height"`
        W float64 `json:"width"`
}

func (t RectFloat) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%f:%f %f:%f", t.X, t.Y, t.W, t.H)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package relativasor

import (
        "os"
        "path/filepath"
        "strings"
)

var rootDirectory string

func Init(r string) error <span class="cov8" title="1">{
        if r != "" </span><span class="cov8" title="1">{
                rootDirectory = r
                return nil
        }</span>

        <span class="cov0" title="0">path, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rootDirectory = path
        return nil</span>
}

func GetRelativePath(url string) string <span class="cov8" title="1">{
        if url == "." </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(url, rootDirectory) </span><span class="cov8" title="1">{
                return url
        }</span>

        <span class="cov8" title="1">relativePath := strings.TrimPrefix(url, rootDirectory)
        return strings.TrimPrefix(relativePath, string(filepath.Separator))</span>
}

func GetAbsoluteFile(url string) string <span class="cov8" title="1">{
        if strings.HasPrefix(url, string(filepath.Separator)) </span><span class="cov0" title="0">{
                return url
        }</span> else<span class="cov8" title="1"> {
                return filepath.Join(rootDirectory, url)
        }</span>
}

func GetRootDirectory() string <span class="cov8" title="1">{
        return rootDirectory
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package items

import (
        "context"
        "encoding/json"
        "io"
        "my-collection/server/pkg/bl/items"
        "my-collection/server/pkg/model"
        "my-collection/server/pkg/relativasor"
        "my-collection/server/pkg/server"
        "my-collection/server/pkg/suggestions"
        "my-collection/server/pkg/utils"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/go-errors/errors"
        "github.com/op/go-logging"
)

var logger = logging.MustGetLogger("items-handler")

type itemsHandlerDb interface {
        model.ItemReaderWriter
        model.TagReader
}

type itemsHandlerProcessor interface {
        EnqueueItemVideoMetadata(ctx context.Context, id uint64, title string) error
        EnqueueItemCovers(ctx context.Context, id uint64, title string) error
        EnqueueCropFrame(ctx context.Context, id uint64, second float64, rect model.RectFloat, title string) error
        EnqueueItemPreview(ctx context.Context, id uint64, title string) error
        EnqueueItemFileMetadata(ctx context.Context, id uint64, title string) error
        EnqueueMainCover(ctx context.Context, id uint64, second float64, title string) error
}

type itemsHandlerOptimizer interface {
        HandleItem(ctx context.Context, item *model.Item)
}

func NewHandler(db itemsHandlerDb, processor itemsHandlerProcessor, optimizer itemsHandlerOptimizer) *itemsHandler <span class="cov8" title="1">{
        return &amp;itemsHandler{
                db:        db,
                processor: processor,
                optimizer: optimizer,
        }
}</span>

type itemsHandler struct {
        db        itemsHandlerDb
        processor itemsHandlerProcessor
        optimizer itemsHandlerOptimizer
}

func (s *itemsHandler) RegisterRoutes(rg *gin.RouterGroup) <span class="cov8" title="1">{
        rg = rg.Group("items")
        rg.GET("", s.getItems)
        rg.POST("", s.createItem)
        rg.POST("/:item", s.updateItem)
        rg.GET("/:item", s.getItem)
        rg.DELETE("/:item", s.deleteItem)
        rg.GET("/:item/location", s.getItemLocation)
        rg.POST("/:item/remove-tag/:tag", s.removeTagFromItem)
        rg.POST("/:item/main-cover", s.setMainCover)
        rg.POST("/:item/split", s.splitItem)
        rg.POST("/:item/make-highlight", s.makeHighlight)
        rg.POST("/:item/crop-frame", s.cropFrame)
        rg.GET("/:item/suggestions", s.getSuggestionsForItem)
        rg.POST("/:item/process", s.refreshItem)
        rg.POST("/:item/optimize", s.optimizeItem)
}</span>

func (s *itemsHandler) createItem(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        body, err := io.ReadAll(c.Request.Body)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var item model.Item
        if server.HandleError(c, json.Unmarshal(body, &amp;item)) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">item.Url = relativasor.GetRelativePath(item.Url)
        item.Origin = relativasor.GetRelativePath(item.Origin)
        if server.HandleError(c, s.db.CreateOrUpdateItem(ctx, &amp;item)) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, model.Item{Id: item.Id})</span>
}

func (s *itemsHandler) updateItem(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        itemId, err := strconv.ParseUint(c.Param("item"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">body, err := io.ReadAll(c.Request.Body)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var item model.Item
        if server.HandleError(c, json.Unmarshal(body, &amp;item)) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if item.Id != 0 &amp;&amp; item.Id != itemId </span><span class="cov0" title="0">{
                server.HandleError(c, errors.Errorf("Mismatch IDs %d != %d", item.Id, itemId))
                return
        }</span>

        <span class="cov8" title="1">item.Id = itemId
        if server.HandleError(c, s.db.UpdateItem(ctx, &amp;item)) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.Status(http.StatusOK)</span>
}

func (s *itemsHandler) getItem(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        itemId, err := strconv.ParseUint(c.Param("item"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">item, err := s.db.GetItem(ctx, itemId)
        if server.HandleError(c, err) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, item)</span>
}

func (s *itemsHandler) deleteItem(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        itemId, err := strconv.ParseUint(c.Param("item"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">deleteRealItem, err := strconv.ParseBool(c.Query("deleteRealFile"))
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if deleteRealItem </span><span class="cov0" title="0">{
                if server.HandleError(c, items.DeleteRealFile(ctx, s.db, itemId)) </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov8" title="1">errs := items.RemoveItemAndItsAssociations(ctx, s.db, itemId)
        if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                if server.HandleError(c, errs[0]) </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov8" title="1">c.Status(http.StatusOK)</span>
}

func (s *itemsHandler) getItemLocation(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        itemId, err := strconv.ParseUint(c.Param("item"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">item, err := s.db.GetItem(ctx, itemId)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, model.FileUrl{
                Url: relativasor.GetAbsoluteFile(item.Url),
        })</span>
}

func (s *itemsHandler) getItems(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        items, err := s.db.GetAllItems(ctx)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">logger.Infof("Get items return %d items", len(*items))
        c.JSON(http.StatusOK, items)</span>
}

func (s *itemsHandler) removeTagFromItem(c *gin.Context) <span class="cov0" title="0">{
        ctx := server.ContextWithSubject(c)
        itemId, err := strconv.ParseUint(c.Param("item"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">tagId, err := strconv.ParseUint(c.Param("tag"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if server.HandleError(c, s.db.RemoveTagFromItem(ctx, itemId, tagId)) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusOK)</span>
}

func (s *itemsHandler) setMainCover(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        itemId, err := strconv.ParseUint(c.Param("item"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">item, err := s.db.GetItem(ctx, itemId)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">second, err := strconv.ParseFloat(c.Query("second"), 64)
        if server.HandleError(c, err) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">logger.Infof("Setting main cover for item %d at %d", itemId, second)
        utils.LogWarning("EnqueueMainCover", s.processor.EnqueueMainCover(ctx, itemId, second, item.Title))
        c.Status(http.StatusOK)</span>
}

func (s *itemsHandler) splitItem(c *gin.Context) <span class="cov0" title="0">{
        ctx := server.ContextWithSubject(c)
        itemId, err := strconv.ParseUint(c.Param("item"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">second, err := strconv.ParseFloat(c.Query("second"), 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">logger.Infof("Splitting item %d at %f", itemId, second)
        changedItems, err := items.Split(ctx, s.db, itemId, second)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for _, item := range changedItems </span><span class="cov0" title="0">{
                utils.LogWarning("EnqueueItemVideoMetadata", s.processor.EnqueueItemVideoMetadata(ctx, item.Id, item.Title))
                utils.LogWarning("EnqueueItemCovers", s.processor.EnqueueItemCovers(ctx, item.Id, item.Title))
                utils.LogWarning("EnqueueItemFileMetadata", s.processor.EnqueueItemFileMetadata(ctx, item.Id, item.Title))
                utils.LogWarning("EnqueueItemPreview", s.processor.EnqueueItemPreview(ctx, item.Id, item.Title))
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusOK)</span>
}

func (s *itemsHandler) makeHighlight(c *gin.Context) <span class="cov0" title="0">{
        ctx := server.ContextWithSubject(c)
        itemId, err := strconv.ParseUint(c.Param("item"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">startSecond, err := strconv.ParseFloat(c.Query("start"), 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">endSecond, err := strconv.ParseFloat(c.Query("end"), 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">highlightId, err := strconv.ParseUint(c.Query("highlight-id"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">logger.Infof("Making highlight for item %d from %f to %f", itemId, startSecond, endSecond)
        highlightItem, err := items.MakeHighlight(ctx, s.db, itemId, startSecond, endSecond, highlightId)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">utils.LogWarning("EnqueueItemVideoMetadata", s.processor.EnqueueItemVideoMetadata(ctx, highlightItem.Id, highlightItem.Title))
        utils.LogWarning("EnqueueItemCovers", s.processor.EnqueueItemCovers(ctx, highlightItem.Id, highlightItem.Title))
        utils.LogWarning("EnqueueItemPreview", s.processor.EnqueueItemPreview(ctx, highlightItem.Id, highlightItem.Title))
        utils.LogWarning("EnqueueItemFileMetadata", s.processor.EnqueueItemFileMetadata(ctx, highlightItem.Id, highlightItem.Title))
        c.Status(http.StatusOK)</span>
}

func (s *itemsHandler) cropFrame(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        itemId, err := strconv.ParseUint(c.Param("item"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">item, err := s.db.GetItem(ctx, itemId)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">second, err := strconv.ParseFloat(c.Query("second"), 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">cropX, err := strconv.ParseFloat(c.Query("crop-x"), 64)
        if server.HandleError(c, err) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">cropY, err := strconv.ParseFloat(c.Query("crop-y"), 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">cropWidth, err := strconv.ParseFloat(c.Query("crop-width"), 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">cropHeight, err := strconv.ParseFloat(c.Query("crop-height"), 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">rect := model.RectFloat{
                X: cropX,
                Y: cropY,
                W: cropWidth,
                H: cropHeight,
        }

        logger.Infof("Cropping frame for item %d at %f %s", itemId, second, rect)
        utils.LogWarning("EnqueueCropFrame", s.processor.EnqueueCropFrame(ctx, itemId, second, rect, item.Title))</span>
}

func (s *itemsHandler) getSuggestionsForItem(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        itemId, err := strconv.ParseUint(c.Param("item"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">result, err := suggestions.GetSuggestionsForItem(ctx, s.db, s.db, itemId, 8)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, result)</span>
}

func (s *itemsHandler) refreshItem(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        itemId, err := strconv.ParseUint(c.Param("item"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">item, err := s.db.GetItem(ctx, itemId)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">utils.LogWarning("EnqueueItemVideoMetadata", s.processor.EnqueueItemVideoMetadata(ctx, item.Id, item.Title))
        utils.LogWarning("EnqueueItemCovers", s.processor.EnqueueItemCovers(ctx, item.Id, item.Title))
        utils.LogWarning("EnqueueItemPreview", s.processor.EnqueueItemPreview(ctx, item.Id, item.Title))
        utils.LogWarning("EnqueueItemFileMetadata", s.processor.EnqueueItemFileMetadata(ctx, item.Id, item.Title))

        c.Status(http.StatusOK)</span>
}

func (s *itemsHandler) optimizeItem(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        itemId, err := strconv.ParseUint(c.Param("item"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">item, err := s.db.GetItem(ctx, itemId)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">s.optimizer.HandleItem(ctx, item)
        c.Status(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package server

import (
        "context"
        "net/http"
        "time"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
        "github.com/op/go-logging"
)

var logger = logging.MustGetLogger("server")

type Server struct {
        addr     string
        router   *gin.Engine
        apiRoute *gin.RouterGroup
}

func New(addr string) *Server <span class="cov0" title="0">{
        gin.SetMode("release")

        router := gin.New()
        router.Use(cors.Default())
        router.Use(httpLogger)

        server := &amp;Server{
                addr:     addr,
                router:   router,
                apiRoute: router.Group("/api"),
        }

        server.registerStaticHandlers()
        return server
}</span>

func (s *Server) RegisterHandler(h Handler) <span class="cov0" title="0">{
        h.RegisterRoutes(s.apiRoute)
}</span>

func (s *Server) registerStaticHandlers() <span class="cov0" title="0">{
        s.router.Static("/ui", "ui/")
        s.router.StaticFile("/", "ui/index.html")
        s.router.GET("/spa/*route", func(c *gin.Context) </span><span class="cov0" title="0">{
                http.ServeFile(c.Writer, c.Request, "ui/index.html")
        }</span>)
}

func (s *Server) Run(ctx context.Context) error <span class="cov0" title="0">{
        logger.Infof("Starting server at address %s", s.addr)

        srv := &amp;http.Server{
                Addr:    s.addr,
                Handler: s.router,
        }

        serverErr := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        serverErr &lt;- err
                }</span>
        }()

        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                logger.Info("Context cancelled, shutting down server gracefully...")
                shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
                defer cancel()

                if err := srv.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Server forced to shutdown: %v", err)
                        return err
                }</span>

                <span class="cov0" title="0">logger.Info("Server exited gracefully")
                return nil</span>
        case err := &lt;-serverErr:<span class="cov0" title="0">
                return err</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package server

import (
        "context"
        "my-collection/server/pkg/utils"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/go-errors/errors"
        "gorm.io/gorm"
)

type Handler interface {
        RegisterRoutes(rg *gin.RouterGroup)
}

func ContextWithSubject(c *gin.Context) context.Context <span class="cov8" title="1">{
        endpoint := c.Request.Method + " " + c.FullPath()
        if endpoint == " " </span><span class="cov0" title="0">{
                // Fallback if FullPath is empty
                endpoint = c.Request.Method + " " + c.Request.URL.Path
        }</span>
        <span class="cov8" title="1">return utils.ContextWithSubject(c.Request.Context(), endpoint)</span>
}

func HandleError(c *gin.Context, err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">httpError := http.StatusInternalServerError
        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                httpError = http.StatusNotFound
        }</span>

        <span class="cov8" title="1">utils.LogError("Server error", err)
        c.AbortWithError(httpError, err)
        return true</span>
}

func logError(err error) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var e *errors.Error
        if errors.As(err, &amp;e) </span><span class="cov0" title="0">{
                logger.Errorf("HTTP Error: %v", e.ErrorStack())
        }</span> else<span class="cov0" title="0"> {
                logger.Errorf("HTTP Error: %v", err)
        }</span>
}

func httpLogger(c *gin.Context) <span class="cov0" title="0">{
        start := time.Now()
        path := c.Request.URL.Path
        raw := c.Request.URL.RawQuery

        c.Next()

        timeStamp := time.Now()
        millis := timeStamp.Sub(start).Milliseconds()

        clientIP := c.ClientIP()
        method := c.Request.Method
        statusCode := c.Writer.Status()
        respSize := c.Writer.Size()
        if raw != "" </span><span class="cov0" title="0">{
                path = path + "?" + raw
        }</span>

        <span class="cov0" title="0">logger.Infof("%s %d %s (resp: %d) (took: %dms) (remote: %s)", method, statusCode, path, respSize, millis, clientIP)

        for _, err := range c.Errors </span><span class="cov0" title="0">{
                logError(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package tags

import (
        "context"
        "encoding/json"
        "io"
        "my-collection/server/pkg/automix"
        "my-collection/server/pkg/bl/directories"
        "my-collection/server/pkg/bl/items"
        "my-collection/server/pkg/bl/tag_annotations"
        "my-collection/server/pkg/bl/tags"
        "my-collection/server/pkg/mixondemand"
        "my-collection/server/pkg/model"
        "my-collection/server/pkg/server"
        "my-collection/server/pkg/spectagger"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/go-errors/errors"
        "github.com/op/go-logging"
)

var logger = logging.MustGetLogger("tags-handler")

type tagsHandlerDb interface {
        model.TagReaderWriter
        model.TagCustomCommandsReader
        model.TagImageWriter
        model.TagImageTypeReaderWriter
        model.TagAnnotationReaderWriter
}

type tagsHandlerProcessor interface {
        ProcessThumbnail(ctx context.Context, image *model.TagImage) error
}

func NewHandler(db tagsHandlerDb, storage model.StorageUploader, processor tagsHandlerProcessor) *tagsHandler <span class="cov8" title="1">{
        return &amp;tagsHandler{
                db:        db,
                storage:   storage,
                processor: processor,
        }
}</span>

type tagsHandler struct {
        db        tagsHandlerDb
        storage   model.StorageUploader
        processor tagsHandlerProcessor
}

func (s *tagsHandler) RegisterRoutes(rg *gin.RouterGroup) <span class="cov8" title="1">{
        rg.GET("/special-tags", s.getSpecialTags)
        rg.GET("/categories", s.getCategories)
        rg = rg.Group("tags")
        rg.GET("", s.getTags)
        rg.POST("", s.createTag)
        rg.POST("/:tag", s.updateTag)
        rg.GET("/:tag", s.getTag)
        rg.DELETE("/:tag", s.removeTag)
        rg.POST("/:tag/auto-image", s.autoImage)
        rg.GET("/:tag/tag-custom-commands", s.getAllTagCustomCommands)
        rg.DELETE("/:tag/tit/:tit", s.removeTagImageFromTag)
        rg.POST("/:tag/images/:image", s.updateTagImage)
        rg.POST("/:tag/random-mix/include", s.randomMixInclude)
        rg.POST("/:tag/random-mix/exclude", s.randomMixExclude)
        rg.POST("/:tag/annotations", s.addAnnotationToTag)
        rg.DELETE("/:tag/annotations/:annotation-id", s.removeAnnotationFromTag)
        rg.GET("/:tag/available-annotations", s.getTagAvailableAnnotations)
        rg.GET("/tag-image-types", s.getTagImageTypes)
}</span>

func (s *tagsHandler) createTag(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        body, err := io.ReadAll(c.Request.Body)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var tag model.Tag
        if server.HandleError(c, json.Unmarshal(body, &amp;tag)) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if server.HandleError(c, s.db.CreateOrUpdateTag(ctx, &amp;tag)) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, model.Tag{Id: tag.Id})</span>
}

func (s *tagsHandler) updateTag(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        tagId, err := strconv.ParseUint(c.Param("tag"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">body, err := io.ReadAll(c.Request.Body)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var tag model.Tag
        if server.HandleError(c, json.Unmarshal(body, &amp;tag)) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if tag.Id != 0 &amp;&amp; tag.Id != tagId </span><span class="cov8" title="1">{
                server.HandleError(c, errors.Errorf("Mismatch IDs %d != %d", tag.Id, tagId))
                return
        }</span>

        <span class="cov8" title="1">tag.Id = tagId
        if server.HandleError(c, s.db.UpdateTag(ctx, &amp;tag)) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.Status(http.StatusOK)</span>
}

func (s *tagsHandler) getTag(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        tagId, err := strconv.ParseUint(c.Param("tag"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">tag, err := s.db.GetTag(ctx, tagId)
        if server.HandleError(c, err) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, tag)</span>
}

func (s *tagsHandler) removeTag(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        tagId, err := strconv.ParseUint(c.Param("tag"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if server.HandleError(c, s.db.RemoveTag(ctx, tagId)) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.Status(http.StatusOK)</span>
}

func (s *tagsHandler) getTags(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        tags, err := s.db.GetAllTags(ctx)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">logger.Infof("Get tags return %d tags", len(*tags))
        c.JSON(http.StatusOK, tags)</span>
}

func (s *tagsHandler) getCategories(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        categories, err := tags.GetCategories(ctx, s.db)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">logger.Infof("Get categories return %d tags", len(*categories))
        c.JSON(http.StatusOK, categories)</span>
}

func (s *tagsHandler) getSpecialTags(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        tags, err := s.db.GetTagsWithoutChildren(ctx,
                directories.GetDirectoriesTagId(),
                automix.GetDailymixTagId(),
                mixondemand.GetMixOnDemandTagId(),
                spectagger.GetSpecTagId(),
                items.GetHighlightsTagId())

        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">logger.Infof("Get special tags return %d tags", len(*tags))
        c.JSON(http.StatusOK, tags)</span>
}

func (s *tagsHandler) autoImage(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        tagId, err := strconv.ParseUint(c.Param("tag"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">tag, err := s.db.GetTag(ctx, tagId)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">body, err := io.ReadAll(c.Request.Body)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var fileUrl model.FileUrl
        if err = json.Unmarshal(body, &amp;fileUrl); err != nil </span><span class="cov0" title="0">{
                server.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">if server.HandleError(c, tags.AutoImageChildren(ctx, s.storage, s.db, s.db, tag, fileUrl.Url)) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, tag)</span>
}

func (s *tagsHandler) getAllTagCustomCommands(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        commands, err := s.db.GetAllTagCustomCommands(ctx)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">logger.Infof("Get tags custom commands return %d commands", len(*commands))
        c.JSON(http.StatusOK, commands)</span>
}

func (s *tagsHandler) removeTagImageFromTag(c *gin.Context) <span class="cov0" title="0">{
        ctx := server.ContextWithSubject(c)
        tagId, err := strconv.ParseUint(c.Param("tag"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">titId, err := strconv.ParseUint(c.Param("tit"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if server.HandleError(c, tags.RemoveTagImages(ctx, s.db, tagId, titId)) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusOK)</span>
}

func (s *tagsHandler) updateTagImage(c *gin.Context) <span class="cov0" title="0">{
        ctx := server.ContextWithSubject(c)
        tagId, err := strconv.ParseUint(c.Param("tag"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">imageId, err := strconv.ParseUint(c.Param("image"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(c.Request.Body)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var image model.TagImage
        if server.HandleError(c, json.Unmarshal(body, &amp;image)) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if image.Id != imageId </span><span class="cov0" title="0">{
                server.HandleError(c, errors.Errorf("Mismatch IDs %d != %d", image.Id, imageId))
                return
        }</span>

        <span class="cov0" title="0">if image.TagId != tagId </span><span class="cov0" title="0">{
                server.HandleError(c, errors.Errorf("Mismatch IDs %d != %d", image.TagId, tagId))
                return
        }</span>

        <span class="cov0" title="0">if server.HandleError(c, s.db.UpdateTagImage(ctx, &amp;image)) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">go s.processor.ProcessThumbnail(ctx, &amp;image)
        c.Status(http.StatusOK)</span>
}

func (s *tagsHandler) randomMixExclude(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        tagId, err := strconv.ParseUint(c.Param("tag"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">tag, err := s.db.GetTag(ctx, tagId)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">noRandom := true
        tag.NoRandom = &amp;noRandom
        if server.HandleError(c, s.db.UpdateTag(ctx, tag)) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.Status(http.StatusOK)</span>
}

func (s *tagsHandler) randomMixInclude(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        tagId, err := strconv.ParseUint(c.Param("tag"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">tag, err := s.db.GetTag(ctx, tagId)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">noRandom := false
        tag.NoRandom = &amp;noRandom
        if server.HandleError(c, s.db.UpdateTag(ctx, tag)) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.Status(http.StatusOK)</span>
}

func (s *tagsHandler) addAnnotationToTag(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        tagId, err := strconv.ParseUint(c.Param("tag"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">body, err := io.ReadAll(c.Request.Body)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var annotation model.TagAnnotation
        if err = json.Unmarshal(body, &amp;annotation); err != nil </span><span class="cov0" title="0">{
                server.HandleError(c, err)
                return
        }</span>

        <span class="cov8" title="1">annotationId, err := tag_annotations.AddAnnotationToTag(ctx, s.db, s.db, tagId, annotation)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, model.TagAnnotation{Id: annotationId})</span>
}

func (s *tagsHandler) removeAnnotationFromTag(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        tagId, err := strconv.ParseUint(c.Param("tag"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">annotationId, err := strconv.ParseUint(c.Param("annotation-id"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if server.HandleError(c, s.db.RemoveTagAnnotationFromTag(ctx, tagId, annotationId)) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.Status(http.StatusOK)</span>
}

func (s *tagsHandler) getTagAvailableAnnotations(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        tagId, err := strconv.ParseUint(c.Param("tag"), 10, 64)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">availableAnnotations, err := tag_annotations.GetTagAvailableAnnotations(ctx, s.db, s.db, tagId)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, availableAnnotations)</span>
}

func (s *tagsHandler) getTagImageTypes(c *gin.Context) <span class="cov8" title="1">{
        ctx := server.ContextWithSubject(c)
        tits, err := s.db.GetAllTagImageTypes(ctx)
        if server.HandleError(c, err) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">logger.Infof("Get tag image types return %d tag image types", len(*tits))
        c.JSON(http.StatusOK, tits)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package spectagger

import (
        "context"
        "my-collection/server/pkg/model"
)

func newCachedTarw(db model.TagAnnotationReaderWriter) *cachedTarw <span class="cov0" title="0">{
        return &amp;cachedTarw{
                db:    db,
                cache: make(map[string]*model.TagAnnotation),
        }
}</span>

type cachedTarw struct {
        db    model.TagAnnotationReaderWriter
        cache map[string]*model.TagAnnotation
}

func (c *cachedTarw) GetTagAnnotation(ctx context.Context, conds ...interface{}) (*model.TagAnnotation, error) <span class="cov0" title="0">{
        if len(conds) == 1 </span><span class="cov0" title="0">{
                if tagAnnotation, ok := conds[0].(*model.TagAnnotation); ok &amp;&amp; tagAnnotation != nil &amp;&amp; tagAnnotation.Title != "" </span><span class="cov0" title="0">{
                        cached, ok := c.cache[tagAnnotation.Title]
                        if ok </span><span class="cov0" title="0">{
                                return cached, nil
                        }</span>

                        <span class="cov0" title="0">result, err := c.db.GetTagAnnotation(ctx, conds...)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">if result != nil </span><span class="cov0" title="0">{
                                c.cache[tagAnnotation.Title] = result
                        }</span>
                        <span class="cov0" title="0">return result, nil</span>
                }
        }

        <span class="cov0" title="0">return c.db.GetTagAnnotation(ctx, conds...)</span>
}

func (c *cachedTarw) GetTagAnnotations(ctx context.Context, tagId uint64) ([]model.TagAnnotation, error) <span class="cov0" title="0">{
        return c.db.GetTagAnnotations(ctx, tagId)
}</span>

func (c *cachedTarw) CreateTagAnnotation(ctx context.Context, tagAnnotation *model.TagAnnotation) error <span class="cov0" title="0">{
        return c.db.CreateTagAnnotation(ctx, tagAnnotation)
}</span>

func (c *cachedTarw) RemoveTag(ctx context.Context, tagId uint64) error <span class="cov0" title="0">{
        return c.db.RemoveTag(ctx, tagId)
}</span>

func (c *cachedTarw) RemoveTagAnnotationFromTag(ctx context.Context, tagId uint64, annotationId uint64) error <span class="cov0" title="0">{
        return c.db.RemoveTagAnnotationFromTag(ctx, tagId, annotationId)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package spectagger

import (
        "context"
        "fmt"
        "my-collection/server/pkg/automix"
        "my-collection/server/pkg/bl/directories"
        "my-collection/server/pkg/bl/items"
        "my-collection/server/pkg/bl/special_tags"
        "my-collection/server/pkg/bl/tag_annotations"
        "my-collection/server/pkg/bl/tags"
        "my-collection/server/pkg/mixondemand"
        "my-collection/server/pkg/model"
        "my-collection/server/pkg/utils"
        "time"

        "github.com/op/go-logging"
)

var logger = logging.MustGetLogger("spectagger")

func GetSpecTagId() uint64 <span class="cov8" title="1">{
        return special_tags.SpecTag.Id
}</span>

type specTaggerDb interface {
        model.TagReaderWriter
        model.ItemReaderWriter
        model.TagAnnotationReaderWriter
}

func New(ctx context.Context, db specTaggerDb) (*Spectagger, error) <span class="cov0" title="0">{
        s, err := db.GetTag(ctx, special_tags.SpecTag)
        if err != nil </span><span class="cov0" title="0">{
                if err := db.CreateOrUpdateTag(ctx, special_tags.SpecTag); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                special_tags.SpecTag = s
        }</span>

        <span class="cov0" title="0">return &amp;Spectagger{
                db:             db,
                triggerChannel: make(chan bool),
        }, nil</span>
}

type Spectagger struct {
        db             specTaggerDb
        triggerChannel chan bool
}

func (d *Spectagger) EnqueueSpecTagger() <span class="cov0" title="0">{
        d.triggerChannel &lt;- true
}</span>

func (d *Spectagger) Run(ctx context.Context) error <span class="cov0" title="0">{
        first := true
        ctx = utils.ContextWithSubject(ctx, "spectagger")

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-d.triggerChannel:<span class="cov0" title="0">
                        d.runSpectagger(ctx)</span>
                case &lt;-time.After(1 * time.Minute):<span class="cov0" title="0">
                        if first </span><span class="cov0" title="0">{
                                d.runSpectagger(ctx)
                        }</span>

                        <span class="cov0" title="0">first = false</span>
                case &lt;-time.After(60 * time.Minute):<span class="cov0" title="0">
                        d.runSpectagger(ctx)</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil</span>
                }
        }
}

func (d *Spectagger) runSpectagger(ctx context.Context) <span class="cov0" title="0">{
        logger.Debugf("Spectagger started")
        if err := d.autoSpectag(ctx); err != nil </span><span class="cov0" title="0">{
                utils.LogError("Error in autoSpectag", err)
        }</span>
        <span class="cov0" title="0">logger.Debugf("Spectagger finished")</span>
}

func (d *Spectagger) autoSpectag(ctx context.Context) error <span class="cov0" title="0">{
        allItems, err := d.db.GetAllItems(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">categories, err := d.GetUserCategories(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">tagTitleToId := make(map[string]uint64)

        cachedTarw := newCachedTarw(d.db)

        for _, item := range *allItems </span><span class="cov0" title="0">{
                resolutionTags, err := getResolutionTags(ctx, cachedTarw, &amp;item)
                if err != nil </span><span class="cov0" title="0">{
                        utils.LogError("Error getting resolution tags", err)
                        continue</span>
                }

                <span class="cov0" title="0">videoCodecTag, err := getVideoCodecTag(ctx, cachedTarw, &amp;item)
                if err != nil </span><span class="cov0" title="0">{
                        utils.LogError("Error getting video codec tag", err)
                        continue</span>
                }

                <span class="cov0" title="0">audioCodecTag, err := getAudioCodecTag(ctx, cachedTarw, &amp;item)
                if err != nil </span><span class="cov0" title="0">{
                        utils.LogError("Error getting audio codec tag", err)
                        continue</span>
                }

                <span class="cov0" title="0">durationTag, err := getDurationTag(ctx, cachedTarw, &amp;item)
                if err != nil </span><span class="cov0" title="0">{
                        utils.LogError("Error getting duration tag", err)
                        continue</span>
                }

                <span class="cov0" title="0">typeTag, typeToRemove, err := getTypeTag(ctx, cachedTarw, &amp;item)
                if err != nil </span><span class="cov0" title="0">{
                        utils.LogError("Error getting type tag", err)
                        continue</span>
                }

                <span class="cov0" title="0">categoryTagsToAdd, categoryTagsToRemove := getCategoryTags(ctx, cachedTarw, categories, &amp;item)
                tagsToAdd := append(categoryTagsToAdd, videoCodecTag, audioCodecTag, durationTag, typeTag)
                tagsToAdd = append(tagsToAdd, resolutionTags...)
                tagsToAdd = removeNils(tagsToAdd)

                if err := addTagsToItem(ctx, &amp;tagTitleToId, d.db, &amp;item, tagsToAdd); err != nil </span><span class="cov0" title="0">{
                        utils.LogError("Error adding tags to item", err)
                        continue</span>
                }

                <span class="cov0" title="0">tagsToRemove := categoryTagsToRemove
                if typeToRemove != nil </span><span class="cov0" title="0">{
                        tagsToRemove = append(tagsToRemove, typeToRemove)
                }</span>

                <span class="cov0" title="0">if err := removeTagsFromItem(ctx, &amp;tagTitleToId, d.db, &amp;item, tagsToRemove); err != nil </span><span class="cov0" title="0">{
                        utils.LogError("Error removing tags from item", err)
                        continue</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func removeNils(tags []*model.Tag) []*model.Tag <span class="cov0" title="0">{
        result := make([]*model.Tag, 0)
        for _, item := range tags </span><span class="cov0" title="0">{
                if item != nil </span><span class="cov0" title="0">{
                        result = append(result, item)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func (d *Spectagger) GetUserCategories(ctx context.Context) (*[]model.Tag, error) <span class="cov0" title="0">{
        categories, err := tags.GetCategories(ctx, d.db)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">userCategories := make([]model.Tag, 0)
        for _, category := range *categories </span><span class="cov0" title="0">{
                if category.Id == directories.GetDirectoriesTagId() ||
                        category.Id == automix.GetDailymixTagId() ||
                        category.Id == mixondemand.GetMixOnDemandTagId() ||
                        category.Id == GetSpecTagId() ||
                        category.Id == items.GetHighlightsTagId() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">userCategories = append(userCategories, category)</span>
        }

        <span class="cov0" title="0">return &amp;userCategories, nil</span>
}

func getCategoryTags(ctx context.Context, tarw model.TagAnnotationReaderWriter, categories *[]model.Tag,
        item *model.Item) ([]*model.Tag, []*model.Tag) <span class="cov0" title="0">{
        categoryTagsToAdd := make([]*model.Tag, 0)
        categoryTagsToRemove := make([]*model.Tag, 0)

        if items.IsHighlight(item) || items.IsSplittedItem(item) </span><span class="cov0" title="0">{
                return categoryTagsToAdd, categoryTagsToRemove
        }</span>

        <span class="cov0" title="0">categoriesExists := getCategoriesExists(categories, item)
        for i, category := range *categories </span><span class="cov0" title="0">{
                missing, err := getMissingFromCategoryTag(ctx, tarw, &amp;category)
                if err != nil </span><span class="cov0" title="0">{
                        utils.LogError("Error getting missing from category tag", err)
                        continue</span>
                }

                <span class="cov0" title="0">belong, err := getBelongToCategoryTag(ctx, tarw, &amp;category)
                if err != nil </span><span class="cov0" title="0">{
                        utils.LogError("Error getting belong to category tag", err)
                        continue</span>
                }

                <span class="cov0" title="0">if categoriesExists[i] </span><span class="cov0" title="0">{
                        categoryTagsToRemove = append(categoryTagsToRemove, missing)
                        categoryTagsToAdd = append(categoryTagsToAdd, belong)
                }</span> else<span class="cov0" title="0"> {
                        categoryTagsToRemove = append(categoryTagsToRemove, belong)
                        categoryTagsToAdd = append(categoryTagsToAdd, missing)
                }</span>
        }

        <span class="cov0" title="0">return categoryTagsToAdd, categoryTagsToRemove</span>
}

func getMissingFromCategoryTag(ctx context.Context, tarw model.TagAnnotationReaderWriter, tag *model.Tag) (*model.Tag, error) <span class="cov0" title="0">{
        ta, err := tag_annotations.GetOrCreateTagAnnoation(ctx, tarw, &amp;model.TagAnnotation{Title: "Categories"})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;model.Tag{
                ParentID:    &amp;special_tags.SpecTag.Id,
                Title:       fmt.Sprintf("Missing %s", tag.Title),
                Annotations: []*model.TagAnnotation{ta},
        }, nil</span>
}

func getBelongToCategoryTag(ctx context.Context, tarw model.TagAnnotationReaderWriter, tag *model.Tag) (*model.Tag, error) <span class="cov0" title="0">{
        ta, err := tag_annotations.GetOrCreateTagAnnoation(ctx, tarw, &amp;model.TagAnnotation{Title: "Categories"})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;model.Tag{
                ParentID:    &amp;special_tags.SpecTag.Id,
                Title:       fmt.Sprintf("Has %s", tag.Title),
                Annotations: []*model.TagAnnotation{ta},
        }, nil</span>
}

func getCategoriesExists(categories *[]model.Tag, item *model.Item) []bool <span class="cov0" title="0">{
        categoriesExists := make([]bool, len(*categories))
        for _, tag := range item.Tags </span><span class="cov0" title="0">{
                for i, category := range *categories </span><span class="cov0" title="0">{
                        if tags.IsBelongToCategory(tag, &amp;category) </span><span class="cov0" title="0">{
                                categoriesExists[i] = true
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return categoriesExists</span>
}

func getResolutionTags(ctx context.Context, tarw model.TagAnnotationReaderWriter, item *model.Item) ([]*model.Tag, error) <span class="cov0" title="0">{
        if item.Width == 0 || item.Height == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">ta, err := tag_annotations.GetOrCreateTagAnnoation(ctx, tarw, &amp;model.TagAnnotation{Title: "Resolutions"})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var tags []*model.Tag

        resolutionTag := &amp;model.Tag{
                ParentID:    &amp;special_tags.SpecTag.Id, // Assuming specTag is defined elsewhere
                Title:       fmt.Sprintf("%d*%d", item.Width, item.Height),
                Annotations: []*model.TagAnnotation{ta},
        }
        tags = append(tags, resolutionTag)

        widthTag := &amp;model.Tag{
                ParentID:    &amp;special_tags.SpecTag.Id,
                Title:       fmt.Sprintf("Width: %d", item.Width),
                Annotations: []*model.TagAnnotation{ta},
        }
        tags = append(tags, widthTag)

        heightTag := &amp;model.Tag{
                ParentID:    &amp;special_tags.SpecTag.Id,
                Title:       fmt.Sprintf("Height: %d", item.Height),
                Annotations: []*model.TagAnnotation{ta},
        }
        tags = append(tags, heightTag)

        return tags, nil</span>
}

func getVideoCodecTag(ctx context.Context, tarw model.TagAnnotationReaderWriter, item *model.Item) (*model.Tag, error) <span class="cov0" title="0">{
        if item.VideoCodecName == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">ta, err := tag_annotations.GetOrCreateTagAnnoation(ctx, tarw, &amp;model.TagAnnotation{Title: "Video Codecs"})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;model.Tag{
                ParentID:    &amp;special_tags.SpecTag.Id,
                Title:       item.VideoCodecName,
                Annotations: []*model.TagAnnotation{ta},
        }, nil</span>
}

func getAudioCodecTag(ctx context.Context, tarw model.TagAnnotationReaderWriter, item *model.Item) (*model.Tag, error) <span class="cov0" title="0">{
        if item.AudioCodecName == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">ta, err := tag_annotations.GetOrCreateTagAnnoation(ctx, tarw, &amp;model.TagAnnotation{Title: "Audio Codecs"})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;model.Tag{
                ParentID:    &amp;special_tags.SpecTag.Id,
                Title:       item.AudioCodecName,
                Annotations: []*model.TagAnnotation{ta},
        }, nil</span>
}

func getTypeTag(ctx context.Context, tarw model.TagAnnotationReaderWriter, item *model.Item) (*model.Tag, *model.Tag, error) <span class="cov0" title="0">{
        ta, err := tag_annotations.GetOrCreateTagAnnoation(ctx, tarw, &amp;model.TagAnnotation{Title: "Type"})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">regularTag := &amp;model.Tag{
                ParentID:    &amp;special_tags.SpecTag.Id,
                Title:       "Regular",
                Annotations: []*model.TagAnnotation{ta},
        }
        var tagToRemove *model.Tag

        title := ""
        if items.IsSplittedItem(item) </span><span class="cov0" title="0">{
                title = "Splitted"
                tagToRemove = regularTag
        }</span> else<span class="cov0" title="0"> if items.IsSubItem(item) </span><span class="cov0" title="0">{
                title = "Sub Item"
                tagToRemove = regularTag
        }</span> else<span class="cov0" title="0"> if items.IsHighlight(item) </span><span class="cov0" title="0">{
                title = "Hightlight"
                tagToRemove = regularTag
        }</span> else<span class="cov0" title="0"> {
                title = "Regular"
        }</span>

        <span class="cov0" title="0">return &amp;model.Tag{
                ParentID:    &amp;special_tags.SpecTag.Id,
                Title:       title,
                Annotations: []*model.TagAnnotation{ta},
        }, tagToRemove, nil</span>
}

func getDurationTag(ctx context.Context, tarw model.TagAnnotationReaderWriter, item *model.Item) (*model.Tag, error) <span class="cov0" title="0">{
        if item.DurationSeconds == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">ta, err := tag_annotations.GetOrCreateTagAnnoation(ctx, tarw, &amp;model.TagAnnotation{Title: "Duration"})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">title := ""
        if item.DurationSeconds &lt; (60 * 15) </span><span class="cov0" title="0">{
                title = "&lt; 15 mintues"
        }</span> else<span class="cov0" title="0"> if item.DurationSeconds &lt; (60 * 30) </span><span class="cov0" title="0">{
                title = "15-30 mintues"
        }</span> else<span class="cov0" title="0"> if item.DurationSeconds &lt; (60 * 45) </span><span class="cov0" title="0">{
                title = "30-45 mintues"
        }</span> else<span class="cov0" title="0"> if item.DurationSeconds &lt; (60 * 60) </span><span class="cov0" title="0">{
                title = "45-60 mintues"
        }</span> else<span class="cov0" title="0"> if item.DurationSeconds &lt; (60 * 90) </span><span class="cov0" title="0">{
                title = "60-90 mintues"
        }</span> else<span class="cov0" title="0"> if item.DurationSeconds &lt; (60 * 120) </span><span class="cov0" title="0">{
                title = "90-120 mintues"
        }</span> else<span class="cov0" title="0"> {
                title = "&gt; 120 minutes"
        }</span>

        <span class="cov0" title="0">return &amp;model.Tag{
                ParentID:    &amp;special_tags.SpecTag.Id,
                Title:       title,
                Annotations: []*model.TagAnnotation{ta},
        }, nil</span>
}

func getTagsWithId(ctx context.Context, tagTitleToId *map[string]uint64, trw model.TagReaderWriter,
        unsavedTags []*model.Tag) ([]*model.Tag, error) <span class="cov0" title="0">{
        savedTags := make([]*model.Tag, 0)
        for _, unsavedTag := range unsavedTags </span><span class="cov0" title="0">{
                id, ok := (*tagTitleToId)[unsavedTag.Title]
                if !ok </span><span class="cov0" title="0">{
                        tag, err := tags.GetOrCreateTag(ctx, trw, unsavedTag)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">id = tag.Id
                        (*tagTitleToId)[unsavedTag.Title] = id</span>
                }

                <span class="cov0" title="0">savedTags = append(savedTags, &amp;model.Tag{Id: id})</span>
        }

        <span class="cov0" title="0">return savedTags, nil</span>
}

func addTagsToItem(ctx context.Context, tagTitleToId *map[string]uint64, db specTaggerDb, item *model.Item, unsavedTags []*model.Tag) error <span class="cov0" title="0">{
        if len(unsavedTags) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">savedTags, err := getTagsWithId(ctx, tagTitleToId, db, unsavedTags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = items.EnsureItemHaveTags(ctx, db, item, savedTags)
        return err</span>
}

func removeTagsFromItem(ctx context.Context, tagTitleToId *map[string]uint64, db specTaggerDb,
        item *model.Item, unsavedTags []*model.Tag) error <span class="cov0" title="0">{
        if len(unsavedTags) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">savedTags, err := getTagsWithId(ctx, tagTitleToId, db, unsavedTags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return items.EnsureItemMissingTags(ctx, db, item, savedTags)</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package storage

import (
        "os"
        "path"
        "path/filepath"
        "strings"

        "github.com/go-errors/errors"
        "github.com/google/uuid"
        "github.com/op/go-logging"
        cp "github.com/otiai10/copy"
)

const (
        TEMP_DIRECTORY     = "temp"
        STORAGE_URL_PREFIX = ".internal-storage"
)

var logger = logging.MustGetLogger("storage")

type Storage struct {
        rootDirectory string
}

func New(rootDirectory string) (*Storage, error) <span class="cov8" title="1">{
        if err := os.MkdirAll(rootDirectory, 0750); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, 0)
        }</span>

        <span class="cov8" title="1">if err := os.MkdirAll(path.Join(rootDirectory, TEMP_DIRECTORY), 0750); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, 0)
        }</span>

        <span class="cov8" title="1">cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, 0)
        }</span>

        <span class="cov8" title="1">storageTemplateDirectory := filepath.Join(cwd, "storage-template")
        if err := cp.Copy(storageTemplateDirectory, rootDirectory, cp.Options{}); err != nil </span><span class="cov8" title="1">{
                logger.Warningf("Error copying storage template from %s to %s - %s", storageTemplateDirectory, rootDirectory, err)
        }</span>

        <span class="cov8" title="1">logger.Infof("Srorage initialized in %s", rootDirectory)

        return &amp;Storage{
                rootDirectory: rootDirectory,
        }, nil</span>
}

func (s *Storage) GetStorageDirectory(name string) string <span class="cov0" title="0">{
        return s.GetFile(name)
}</span>

func (s *Storage) Put(name string, bytes []byte) error <span class="cov0" title="0">{
        return os.WriteFile(s.GetFile(name), bytes, 0750)
}</span>

func (s *Storage) Get(name string) ([]byte, error) <span class="cov0" title="0">{
        return os.ReadFile(s.GetFile(name))
}</span>

func (s *Storage) GetFile(name string) string <span class="cov0" title="0">{
        return filepath.Join(s.rootDirectory, strings.TrimPrefix(name, STORAGE_URL_PREFIX))
}</span>

func (s *Storage) GetStorageUrl(name string) string <span class="cov0" title="0">{
        return filepath.Join(".internal-storage", name)
}</span>

func (s *Storage) IsStorageUrl(name string) bool <span class="cov0" title="0">{
        return strings.HasPrefix(name, STORAGE_URL_PREFIX)
}</span>

func (s *Storage) GetFileForWriting(name string) (string, error) <span class="cov0" title="0">{
        path := s.GetFile(name)
        if err := os.MkdirAll(filepath.Dir(path), 0750); err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, 0)
        }</span>

        <span class="cov0" title="0">return path, nil</span>
}

func (s *Storage) GetTempFile() string <span class="cov0" title="0">{
        return filepath.Join(s.rootDirectory, TEMP_DIRECTORY, uuid.New().String())
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package suggestions

import (
        "context"
        "math/rand"
        "my-collection/server/pkg/bl/items"
        "my-collection/server/pkg/bl/special_tags"
        "my-collection/server/pkg/bl/tags"
        "my-collection/server/pkg/model"
)

func GetSuggestionsForItem(ctx context.Context, ir model.ItemReader, tr model.TagReader, itemId uint64, count int) ([]*model.Item, error) <span class="cov8" title="1">{
        item, err := ir.GetItem(ctx, itemId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">t, err := tags.GetFullTags(ctx, tr, item.Tags)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return GetSuggestionsForTags(ctx, ir, tr, t, count)</span>
}

func GetSuggestionsForTags(ctx context.Context, ir model.ItemReader, tr model.TagReader, tags *[]model.Tag, count int) ([]*model.Item, error) <span class="cov8" title="1">{
        relatedItems, err := getItemsOfTags(ctx, ir, tags)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(relatedItems) &lt; count </span><span class="cov8" title="1">{
                randomItems, err := items.GetRandomItems(ctx, ir, count-len(relatedItems), func(item *model.Item) bool </span><span class="cov0" title="0">{
                        return !items.IsHighlight(item) &amp;&amp; !items.IsSplittedItem(item)
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">relatedItems = append(relatedItems, randomItems...)</span>
        }

        // Safety check: if we still don't have enough items, adjust count
        <span class="cov8" title="1">if len(relatedItems) == 0 </span><span class="cov0" title="0">{
                return []*model.Item{}, nil
        }</span>

        <span class="cov8" title="1">if count &gt; len(relatedItems) </span><span class="cov8" title="1">{
                count = len(relatedItems)
        }</span>

        <span class="cov8" title="1">resultIndexes := getUniqueRandomNumbers(len(relatedItems), count)
        result := make([]*model.Item, len(resultIndexes))
        for i, n := range resultIndexes </span><span class="cov8" title="1">{
                result[i] = relatedItems[n-1]
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func getItemsOfTags(ctx context.Context, ir model.ItemReader, t *[]model.Tag) ([]*model.Item, error) <span class="cov8" title="1">{
        relatedItems := make([]*model.Item, 0)

        for _, tag := range *t </span><span class="cov8" title="1">{
                if special_tags.IsSpecial(*tag.ParentID) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">tagItems, err := tags.GetItems(ctx, ir, &amp;tag)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">for _, item := range *tagItems </span><span class="cov8" title="1">{
                        if !items.ItemExists(relatedItems, &amp;item) </span><span class="cov8" title="1">{
                                fake := item
                                relatedItems = append(relatedItems, &amp;fake)
                        }</span>
                }
        }

        <span class="cov8" title="1">return relatedItems, nil</span>
}

func getUniqueRandomNumbers(max int, count int) []int <span class="cov8" title="1">{
        // Safety check: can't generate more unique numbers than available
        if count &gt; max </span><span class="cov0" title="0">{
                count = max
        }</span>

        // If no numbers can be generated, return empty slice
        <span class="cov8" title="1">if max &lt;= 0 || count &lt;= 0 </span><span class="cov0" title="0">{
                return []int{}
        }</span>

        <span class="cov8" title="1">result := make([]int, count)

        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                num := rand.Intn(max) + 1
                for numberExists(result, num) </span><span class="cov0" title="0">{
                        num = rand.Intn(max) + 1
                }</span>

                <span class="cov8" title="1">result[i] = num</span>
        }

        <span class="cov8" title="1">return result</span>
}

func numberExists(nums []int, num int) bool <span class="cov8" title="1">{
        for _, n := range nums </span><span class="cov8" title="1">{
                if n == num </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package utils

import (
        "bufio"
        "bytes"
        "image"
        "image/png"
        "io"
        "math"
        "net/http"
        "os"
        "path/filepath"
        "strings"

        _ "image/jpeg"
        _ "image/png"

        "golang.org/x/image/draw"
        "golang.org/x/text/encoding"
        "golang.org/x/text/encoding/charmap"
        "golang.org/x/text/transform"

        "github.com/h2non/filetype"
        "github.com/op/go-logging"
        "github.com/saintfish/chardet"
)

var logger = logging.MustGetLogger("utils")

func IsVideo(trustFileExtenssion bool, path string) bool <span class="cov0" title="0">{
        if trustFileExtenssion </span><span class="cov0" title="0">{
                path = strings.ToLower(path)
                return strings.HasSuffix(path, ".avi") ||
                        strings.HasSuffix(path, ".mkv") ||
                        strings.HasSuffix(path, ".mpg") ||
                        strings.HasSuffix(path, ".mpeg") ||
                        strings.HasSuffix(path, ".wmv") ||
                        strings.HasSuffix(path, ".mp4")
        }</span>

        <span class="cov0" title="0">file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error opening file for reading %s - %t", file, err)
                return false
        }</span>

        <span class="cov0" title="0">stat, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error getting stats of file %s - %t", path, err)
                return false
        }</span>

        <span class="cov0" title="0">header := make([]byte, int(math.Max(float64(stat.Size())-1, 1024)))
        _, err = file.Read(header)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error reading from file %s - %t", path, err)
                return false
        }</span>

        <span class="cov0" title="0">return filetype.IsVideo(header)</span>
}

func DownloadFile(url string, targetFile string) error <span class="cov0" title="0">{
        resp, err := http.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        out, err := os.Create(targetFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer out.Close()

        _, err = io.Copy(out, resp.Body)
        return err</span>
}

func ExtractImage(imageFile, outputFile string, x, y, width, height, destWidth, destHeight int) error <span class="cov0" title="0">{
        inFile, err := os.Open(imageFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer inFile.Close()

        img, _, err := image.Decode(inFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rect := image.Rect(x, y, x+width, y+height)
        subImg := img.(interface {
                SubImage(r image.Rectangle) image.Image
        }).SubImage(rect)

        resizedImg := image.NewRGBA(image.Rect(0, 0, destWidth, destHeight))
        draw.ApproxBiLinear.Scale(resizedImg, resizedImg.Bounds(), subImg, subImg.Bounds(), draw.Over, nil)

        outFile, err := os.Create(outputFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer outFile.Close()

        return png.Encode(outFile, resizedImg)</span>
}

func BaseRemoveExtension(filename string) string <span class="cov0" title="0">{
        ext := filepath.Ext(filepath.Base(filename))
        return filename[:len(filename)-len(ext)]
}</span>

func DetectEncodingAndRead(filename string) (string, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">detector := chardet.NewTextDetector()
        result, err := detector.DetectBest(data)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if result.Charset != "UTF-8" </span><span class="cov0" title="0">{
                var decoder *encoding.Decoder
                switch result.Charset </span>{
                case "ISO-8859-1", "windows-1252":<span class="cov0" title="0">
                        decoder = charmap.Windows1252.NewDecoder()</span>
                case "ISO-8859-15":<span class="cov0" title="0">
                        decoder = charmap.ISO8859_15.NewDecoder()</span>
                case "ISO-8859-8-I":<span class="cov0" title="0">
                        decoder = charmap.ISO8859_8I.NewDecoder()</span>
                case "ISO-8859-2":<span class="cov0" title="0">
                        decoder = charmap.ISO8859_2.NewDecoder()</span>
                case "ISO-8859-3":<span class="cov0" title="0">
                        decoder = charmap.ISO8859_3.NewDecoder()</span>
                case "ISO-8859-4":<span class="cov0" title="0">
                        decoder = charmap.ISO8859_4.NewDecoder()</span>
                case "ISO-8859-5":<span class="cov0" title="0">
                        decoder = charmap.ISO8859_5.NewDecoder()</span>
                case "ISO-8859-6":<span class="cov0" title="0">
                        decoder = charmap.ISO8859_6.NewDecoder()</span>
                case "ISO-8859-7":<span class="cov0" title="0">
                        decoder = charmap.ISO8859_7.NewDecoder()</span>
                case "ISO-8859-8":<span class="cov0" title="0">
                        decoder = charmap.ISO8859_8.NewDecoder()</span>
                case "ISO-8859-9":<span class="cov0" title="0">
                        decoder = charmap.ISO8859_9.NewDecoder()</span>
                case "ISO-8859-10":<span class="cov0" title="0">
                        decoder = charmap.ISO8859_10.NewDecoder()</span>
                case "ISO-8859-13":<span class="cov0" title="0">
                        decoder = charmap.ISO8859_13.NewDecoder()</span>
                case "ISO-8859-14":<span class="cov0" title="0">
                        decoder = charmap.ISO8859_14.NewDecoder()</span>
                case "ISO-8859-16":<span class="cov0" title="0">
                        decoder = charmap.ISO8859_16.NewDecoder()</span>
                case "windows-1250":<span class="cov0" title="0">
                        decoder = charmap.Windows1250.NewDecoder()</span>
                case "windows-1251":<span class="cov0" title="0">
                        decoder = charmap.Windows1251.NewDecoder()</span>
                case "windows-1253":<span class="cov0" title="0">
                        decoder = charmap.Windows1253.NewDecoder()</span>
                case "windows-1254":<span class="cov0" title="0">
                        decoder = charmap.Windows1254.NewDecoder()</span>
                case "windows-1255":<span class="cov0" title="0">
                        decoder = charmap.Windows1255.NewDecoder()</span>
                case "windows-1256":<span class="cov0" title="0">
                        decoder = charmap.Windows1256.NewDecoder()</span>
                case "windows-1257":<span class="cov0" title="0">
                        decoder = charmap.Windows1257.NewDecoder()</span>
                case "windows-1258":<span class="cov0" title="0">
                        decoder = charmap.Windows1258.NewDecoder()</span>
                case "windows-874":<span class="cov0" title="0">
                        decoder = charmap.Windows874.NewDecoder()</span>
                case "KOI8-R":<span class="cov0" title="0">
                        decoder = charmap.KOI8R.NewDecoder()</span>
                case "KOI8-U":<span class="cov0" title="0">
                        decoder = charmap.KOI8U.NewDecoder()</span>
                case "macintosh":<span class="cov0" title="0">
                        decoder = charmap.Macintosh.NewDecoder()</span>
                case "IBM437":<span class="cov0" title="0">
                        decoder = charmap.CodePage437.NewDecoder()</span>
                case "IBM850":<span class="cov0" title="0">
                        decoder = charmap.CodePage850.NewDecoder()</span>
                case "IBM852":<span class="cov0" title="0">
                        decoder = charmap.CodePage852.NewDecoder()</span>
                case "IBM855":<span class="cov0" title="0">
                        decoder = charmap.CodePage855.NewDecoder()</span>
                case "IBM858":<span class="cov0" title="0">
                        decoder = charmap.CodePage858.NewDecoder()</span>
                case "IBM860":<span class="cov0" title="0">
                        decoder = charmap.CodePage860.NewDecoder()</span>
                case "IBM862":<span class="cov0" title="0">
                        decoder = charmap.CodePage862.NewDecoder()</span>
                case "IBM863":<span class="cov0" title="0">
                        decoder = charmap.CodePage863.NewDecoder()</span>
                case "IBM865":<span class="cov0" title="0">
                        decoder = charmap.CodePage865.NewDecoder()</span>
                case "IBM866":<span class="cov0" title="0">
                        decoder = charmap.CodePage866.NewDecoder()</span>
                default:<span class="cov0" title="0">
                        return string(data), nil</span> // fallback
                }

                <span class="cov0" title="0">reader := transform.NewReader(bytes.NewReader(data), decoder)
                decoded, err := io.ReadAll(reader)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">return string(decoded), nil</span>
        }

        <span class="cov0" title="0">return string(data), nil</span>
}

func ReadLines(path string) ([]string, error) <span class="cov0" title="0">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        scanner := bufio.NewScanner(file)

        var lines []string
        for scanner.Scan() </span><span class="cov0" title="0">{
                lines = append(lines, scanner.Text())
        }</span>

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return lines, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package utils

import (
        "context"
        "fmt"
        "os"
        "strings"

        "github.com/go-errors/errors"
        "github.com/op/go-logging"
)

type contextKey string

const subjectContextKey contextKey = "subject"

func ConfigureLogger() error <span class="cov0" title="0">{
        logFormat := `[%{time:2006-01-02 15:04:05.000}] %{color}%{level:-7s}%{color:reset} %{message} [%{module} - %{shortfile}]`
        formatter, err := logging.NewStringFormatter(logFormat)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logging.SetBackend(logging.NewLogBackend(os.Stdout, "", 0))
        logging.SetFormatter(formatter)

        logger.Debugf("Logger initialized with format %v", logFormat)
        return nil</span>
}

func LogError(message string, err error) <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var e *errors.Error
        if errors.As(err, &amp;e) </span><span class="cov8" title="1">{
                logger.Errorf("Error: %s %v", message, e.ErrorStack())
        }</span> else<span class="cov8" title="1"> {
                logger.Errorf("Error: %s %s", message, squashString(fmt.Sprintf("%v", err)))
        }</span>
}

func LogWarning(message string, err error) <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">logger.Warningf("Warning: %s %s", message, squashString(fmt.Sprintf("%v", err)))</span>
}

func squashString(str string) string <span class="cov8" title="1">{
        return strings.ReplaceAll(strings.ReplaceAll(str, "\n", ""), "\r", "")
}</span>

func ContextWithSubject(parent context.Context, subject string) context.Context <span class="cov8" title="1">{
        return context.WithValue(parent, subjectContextKey, subject)
}</span>

func GetSubject(ctx context.Context) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s", ctx.Value(subjectContextKey))
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package utils

import (
        "my-collection/server/pkg/model"
        "time"
)

type NowTimeGetter struct {
}

func (d NowTimeGetter) GetCurrentTime() time.Time <span class="cov0" title="0">{
        return time.Now()
}</span>

type VideoFilter struct {
}

func (f VideoFilter) Filter(path string) bool <span class="cov0" title="0">{
        return IsVideo(true, path)
}</span>

type PushSender struct {
        listeners []model.PushListener
}

func (f *PushSender) AddPushListener(l model.PushListener) <span class="cov0" title="0">{
        f.listeners = append(f.listeners, l)
}</span>

func (f *PushSender) Push(m model.PushMessage) <span class="cov8" title="1">{
        if f.listeners == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">for _, l := range f.listeners </span><span class="cov0" title="0">{
                l.Push(m)
        }</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package testutils

import (
        "context"
        "fmt"
        "my-collection/server/pkg/bl/directories"
        "my-collection/server/pkg/db"
        "my-collection/server/pkg/fssync"
        "my-collection/server/pkg/model"
        "my-collection/server/pkg/relativasor"
        "os"
        "path/filepath"
        "strings"
        "testing"
        "time"

        "github.com/stretchr/testify/assert"
        "github.com/stretchr/testify/require"
)

// IntegrationTestFramework provides utilities for integration testing with real DB and filesystem
type IntegrationTestFramework struct {
        t           *testing.T
        tempDir     string
        dbFile      string
        database    db.Database
        fsManager   *fssync.FsManager
        dig         model.DirectoryItemsGetter
        initialSync bool
}

type testFileFilter struct {
}

func (f testFileFilter) Filter(path string) bool <span class="cov8" title="1">{
        // Accept all files except hidden ones for testing
        base := filepath.Base(path)
        return !strings.HasPrefix(base, ".")
}</span>

// NewIntegrationTestFramework creates a new test framework with fresh DB and filesystem
func NewIntegrationTestFramework(t *testing.T) *IntegrationTestFramework <span class="cov8" title="1">{
        tempDir, err := os.MkdirTemp("", "integration-test-*")
        require.NoError(t, err)
        rootDir := filepath.Join(tempDir, "root")
        require.NoError(t, os.Mkdir(rootDir, 0755))

        dbFile := filepath.Join(tempDir, "test.db")
        database, err := db.New(dbFile, false)
        require.NoError(t, err)

        // Initialize relativasor with our test directory
        relativasor.Init(rootDir)

        // Initialize directories and tags subsystems
        err = directories.Init(context.Background(), database)
        require.NoError(t, err)

        // Create FsManager with filter that accepts all files
        fsManager, err := fssync.NewFsManager(context.Background(), database, testFileFilter{}, time.Hour) // Long interval since we sync manually
        require.NoError(t, err)

        return &amp;IntegrationTestFramework{
                t:         t,
                tempDir:   rootDir,
                dbFile:    dbFile,
                database:  database,
                fsManager: fsManager,
                dig:       fsManager,
        }
}</span>

// Cleanup removes temporary files and closes database
func (f *IntegrationTestFramework) Cleanup() <span class="cov8" title="1">{
        if f.database != nil </span>{<span class="cov8" title="1">
                // Close database connection if possible
                // Note: gorm doesn't expose Close directly, but it will be closed when the process ends
        }</span>
        <span class="cov8" title="1">if f.tempDir != "" </span><span class="cov8" title="1">{
                os.RemoveAll(f.tempDir)
        }</span>
}

// GetTempDir returns the temporary directory path for this test
func (f *IntegrationTestFramework) GetTempDir() string <span class="cov8" title="1">{
        return f.tempDir
}</span>

// GetDatabase returns the test database instance
func (f *IntegrationTestFramework) GetDatabase() db.Database <span class="cov8" title="1">{
        return f.database
}</span>

// GetFsManager returns the filesystem manager instance
func (f *IntegrationTestFramework) GetDirectoryItemsGetter() model.DirectoryItemsGetter <span class="cov8" title="1">{
        return f.dig
}</span>

// CreateFile creates a file with given content at the specified relative path
func (f *IntegrationTestFramework) CreateFile(relativePath string, content string) <span class="cov8" title="1">{
        fullPath := filepath.Join(f.tempDir, relativePath)
        err := os.MkdirAll(filepath.Dir(fullPath), 0755)
        require.NoError(f.t, err)

        err = os.WriteFile(fullPath, []byte(content), 0644)
        require.NoError(f.t, err)
}</span>

// CreateDir creates a directory at the specified relative path
func (f *IntegrationTestFramework) CreateDir(relativePath string) <span class="cov8" title="1">{
        fullPath := filepath.Join(f.tempDir, relativePath)
        err := os.MkdirAll(fullPath, 0755)
        require.NoError(f.t, err)
}</span>

// DeleteFile deletes a file at the specified relative path
func (f *IntegrationTestFramework) DeleteFile(relativePath string) <span class="cov8" title="1">{
        fullPath := filepath.Join(f.tempDir, relativePath)
        err := os.Remove(fullPath)
        require.NoError(f.t, err)
}</span>

// DeleteDir deletes a directory at the specified relative path
func (f *IntegrationTestFramework) DeleteDir(relativePath string) <span class="cov8" title="1">{
        fullPath := filepath.Join(f.tempDir, relativePath)
        err := os.RemoveAll(fullPath)
        require.NoError(f.t, err)
}</span>

// MoveFile moves a file from src to dst (both relative paths)
func (f *IntegrationTestFramework) MoveFile(src, dst string) <span class="cov8" title="1">{
        srcPath := filepath.Join(f.tempDir, src)
        dstPath := filepath.Join(f.tempDir, dst)

        // Ensure destination directory exists
        err := os.MkdirAll(filepath.Dir(dstPath), 0755)
        require.NoError(f.t, err)

        err = os.Rename(srcPath, dstPath)
        require.NoError(f.t, err)
}</span>

// MoveDir moves a directory from src to dst (both relative paths)
func (f *IntegrationTestFramework) MoveDir(src, dst string) <span class="cov8" title="1">{
        srcPath := filepath.Join(f.tempDir, src)
        dstPath := filepath.Join(f.tempDir, dst)

        // Ensure parent of destination directory exists
        err := os.MkdirAll(filepath.Dir(dstPath), 0755)
        require.NoError(f.t, err)

        err = os.Rename(srcPath, dstPath)
        require.NoError(f.t, err)
}</span>

// Sync performs a filesystem synchronization
func (f *IntegrationTestFramework) Sync() <span class="cov8" title="1">{
        err := f.fsManager.Sync(context.Background())
        require.NoError(f.t, err)
        f.initialSync = true
}</span>

// includeAllDirectories makes all directories non-excluded for testing
// Returns (hadExcluded, error) where hadExcluded indicates if any directories were included

// GetItems returns all items for a given directory path
func (f *IntegrationTestFramework) GetItems(dirPath string) []model.Item <span class="cov8" title="1">{
        items, err := f.fsManager.GetBelongingItems(context.Background(), directories.NormalizeDirectoryPath(dirPath))
        require.NoError(f.t, err)
        if items == nil </span><span class="cov0" title="0">{
                return []model.Item{}
        }</span>
        <span class="cov8" title="1">return *items</span>
}

// GetDirectories returns all directories from the database
func (f *IntegrationTestFramework) GetDirectories() []model.Directory <span class="cov0" title="0">{
        dirs, err := f.database.GetAllDirectories(context.Background())
        require.NoError(f.t, err)
        return *dirs
}</span>

// GetTags returns all tags from the database
func (f *IntegrationTestFramework) GetTags() []model.Tag <span class="cov8" title="1">{
        tags, err := f.database.GetAllTags(context.Background())
        require.NoError(f.t, err)
        return *tags
}</span>

// AssertItemExists checks that an item with the given title exists in the given directory
func (f *IntegrationTestFramework) AssertItemExists(dirPath, filename string) <span class="cov8" title="1">{
        item, err := f.fsManager.GetBelongingItem(context.Background(), directories.NormalizeDirectoryPath(dirPath), filename)
        require.NoError(f.t, err)
        assert.NotNil(f.t, item, "Item %s should exist in directory %s", filename, dirPath)
}</span>

// AssertItemNotExists checks that an item with the given title does not exist in the given directory
func (f *IntegrationTestFramework) AssertItemNotExists(dirPath, filename string) <span class="cov8" title="1">{
        item, err := f.fsManager.GetBelongingItem(context.Background(), directories.NormalizeDirectoryPath(dirPath), filename)
        require.NoError(f.t, err)
        assert.Nil(f.t, item, "Item %s should not exist in directory %s", filename, dirPath)
}</span>

// AssertDirectoryExists checks that a directory exists in the database
func (f *IntegrationTestFramework) AssertDirectoryExists(path string) <span class="cov8" title="1">{
        dir, err := f.database.GetDirectory(context.Background(), "path = ?", directories.NormalizeDirectoryPath(path))
        require.NoError(f.t, err)
        assert.NotNil(f.t, dir, "Directory %s should exist in database", path)
}</span>

// AssertDirectoryNotExists checks that a directory does not exist in the database
func (f *IntegrationTestFramework) AssertDirectoryNotExists(path string) <span class="cov8" title="1">{
        dir, err := f.database.GetDirectory(context.Background(), "path = ?", directories.NormalizeDirectoryPath(path))
        if err != nil </span><span class="cov8" title="1">{
                // Record not found is expected
                return
        }</span>
        <span class="cov0" title="0">assert.Nil(f.t, dir, "Directory %s should not exist in database", path)</span>
}

// AssertAutoTagsExist checks that AutoTags are properly applied to items in a directory
func (f *IntegrationTestFramework) AssertAutoTagsExist(dirPath string, expectedAutoTagTitles []string) <span class="cov8" title="1">{
        items := f.GetItems(dirPath)
        for _, item := range items </span><span class="cov8" title="1">{
                itemAutoTags := make([]string, 0)
                for _, tag := range item.Tags </span><span class="cov8" title="1">{
                        // Check if this is an AutoTag (directory-based tag)
                        if tag.ParentID != nil &amp;&amp; *tag.ParentID == directories.GetDirectoriesTagId() </span><span class="cov8" title="1">{
                                itemAutoTags = append(itemAutoTags, tag.Title)
                        }</span>
                }

                <span class="cov8" title="1">for _, expectedTag := range expectedAutoTagTitles </span><span class="cov8" title="1">{
                        assert.Contains(f.t, itemAutoTags, expectedTag,
                                "Item %s in directory %s should have AutoTag %s", item.Title, dirPath, expectedTag)
                }</span>
        }
}

// CreateTestLibrary creates a realistic test library structure
func (f *IntegrationTestFramework) CreateTestLibrary() <span class="cov8" title="1">{
        // Create a realistic media library structure
        structure := map[string]string{
                "movies/action/2023/terminator.mp4":            "action movie content",
                "movies/action/2022/john_wick.mp4":             "action movie content",
                "movies/comedy/2023/ghostbusters.mp4":          "comedy movie content",
                "movies/drama/2022/the_batman.mp4":             "drama movie content",
                "tv/drama/breaking_bad/s01/e01.mp4":            "tv episode content",
                "tv/drama/breaking_bad/s01/e02.mp4":            "tv episode content",
                "tv/comedy/office/s01/e01.mp4":                 "tv episode content",
                "documentaries/nature/planet_earth_s01e01.mp4": "documentary content",
                "music/rock/album1/song1.mp3":                  "music content",
                "music/jazz/album2/song2.mp3":                  "music content",
        }

        for path, content := range structure </span><span class="cov8" title="1">{
                f.CreateFile(path, content)
        }</span>
}

// AssertTestLibraryExists verifies the test library was created correctly
func (f *IntegrationTestFramework) AssertTestLibraryExists() <span class="cov8" title="1">{
        expectedItems := map[string][]string{
                "movies/action/2023":        {"terminator.mp4"},
                "movies/action/2022":        {"john_wick.mp4"},
                "movies/comedy/2023":        {"ghostbusters.mp4"},
                "movies/drama/2022":         {"the_batman.mp4"},
                "tv/drama/breaking_bad/s01": {"e01.mp4", "e02.mp4"},
                "tv/comedy/office/s01":      {"e01.mp4"},
                "documentaries/nature":      {"planet_earth_s01e01.mp4"},
                "music/rock/album1":         {"song1.mp3"},
                "music/jazz/album2":         {"song2.mp3"},
        }

        for dir, files := range expectedItems </span><span class="cov8" title="1">{
                for _, file := range files </span><span class="cov8" title="1">{
                        f.AssertItemExists(dir, file)
                }</span>
        }
}

// WaitForOperation waits for an operation to complete (useful for async operations)
func (f *IntegrationTestFramework) WaitForOperation(timeout time.Duration, operation func() bool) bool <span class="cov0" title="0">{
        start := time.Now()
        for time.Since(start) &lt; timeout </span><span class="cov0" title="0">{
                if operation() </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">time.Sleep(10 * time.Millisecond)</span>
        }
        <span class="cov0" title="0">return false</span>
}

// CreateLargeTestSet creates a large number of files for stress testing
func (f *IntegrationTestFramework) CreateLargeTestSet(dirCount, filesPerDir int) <span class="cov0" title="0">{
        for i := 0; i &lt; dirCount; i++ </span><span class="cov0" title="0">{
                for j := 0; j &lt; filesPerDir; j++ </span><span class="cov0" title="0">{
                        path := fmt.Sprintf("large_test/dir%03d/file%03d.mp4", i, j)
                        content := fmt.Sprintf("test content %d_%d", i, j)
                        f.CreateFile(path, content)
                }</span>
        }
}

// GetAllItems returns all items from the database
func (f *IntegrationTestFramework) GetAllItems() []model.Item <span class="cov0" title="0">{
        items, err := f.database.GetAllItems(context.Background())
        require.NoError(f.t, err)
        if items == nil </span><span class="cov0" title="0">{
                return []model.Item{}
        }</span>
        <span class="cov0" title="0">return *items</span>
}

// CountItemsInDirectory counts all items in a directory and its subdirectories
func (f *IntegrationTestFramework) CountItemsInDirectory(dirPath string) int <span class="cov0" title="0">{
        allItems := f.GetAllItems()
        count := 0
        normalizedPath := directories.NormalizeDirectoryPath(dirPath)

        for _, item := range allItems </span><span class="cov0" title="0">{
                // Check if item's origin starts with the directory path
                if normalizedPath == model.ROOT_DIRECTORY_PATH </span><span class="cov0" title="0">{
                        // For root directory, count all items
                        count++
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(item.Origin, normalizedPath+"/") || item.Origin == normalizedPath </span><span class="cov0" title="0">{
                        count++
                }</span>
        }

        <span class="cov0" title="0">return count</span>
}

func (f *IntegrationTestFramework) AutoIncludeHierarchy(dirPath string) error <span class="cov8" title="1">{
        return directories.AutoIncludeHierarchy(context.Background(), f.database, dirPath)
}</span>

// AddCustomTagsToDirectory adds custom tags to a directory that will be applied as AutoTags to files
func (f *IntegrationTestFramework) AddCustomTagsToDirectory(dirPath string, customTags []*model.Tag) <span class="cov8" title="1">{
        normalizedPath := directories.NormalizeDirectoryPath(dirPath)

        // Get the directory from database
        dir, err := f.database.GetDirectory(context.Background(), "path = ?", normalizedPath)
        require.NoError(f.t, err)
        require.NotNil(f.t, dir, "Directory %s should exist before adding custom tags", dirPath)

        // Update directory tags
        dir.Tags = customTags
        err = f.database.CreateOrUpdateDirectory(context.Background(), dir)
        require.NoError(f.t, err)
}</span>

// AssertCustomAutoTagExists checks that a file has a custom AutoTag (child of a specific parent tag)
func (f *IntegrationTestFramework) AssertCustomAutoTagExists(dirPath, filename string, parentTag *model.Tag, expectedTitle string) <span class="cov8" title="1">{
        item, err := f.fsManager.GetBelongingItem(context.Background(), directories.NormalizeDirectoryPath(dirPath), filename)
        require.NoError(f.t, err)
        require.NotNil(f.t, item, "Item %s should exist in directory %s", filename, dirPath)

        hasCustomAutoTag := false
        for _, tag := range item.Tags </span><span class="cov8" title="1">{
                if tag.ParentID != nil &amp;&amp; *tag.ParentID == parentTag.Id &amp;&amp; tag.Title == expectedTitle </span><span class="cov8" title="1">{
                        hasCustomAutoTag = true
                        break</span>
                }
        }

        <span class="cov8" title="1">assert.True(f.t, hasCustomAutoTag,
                "Item %s should have custom AutoTag '%s' (child of '%s') in directory %s",
                filename, expectedTitle, parentTag.Title, dirPath)</span>
}

// AssertCustomAutoTagNotExists checks that a file does not have a custom AutoTag from a specific parent
func (f *IntegrationTestFramework) AssertCustomAutoTagNotExists(dirPath, filename string, parentTag *model.Tag) <span class="cov0" title="0">{
        item, err := f.fsManager.GetBelongingItem(context.Background(), directories.NormalizeDirectoryPath(dirPath), filename)
        require.NoError(f.t, err)
        require.NotNil(f.t, item, "Item %s should exist in directory %s", filename, dirPath)

        hasCustomAutoTag := false
        for _, tag := range item.Tags </span><span class="cov0" title="0">{
                if tag.ParentID != nil &amp;&amp; *tag.ParentID == parentTag.Id </span><span class="cov0" title="0">{
                        hasCustomAutoTag = true
                        break</span>
                }
        }

        <span class="cov0" title="0">assert.False(f.t, hasCustomAutoTag,
                "Item %s should not have any custom AutoTag from parent '%s' in directory %s",
                filename, parentTag.Title, dirPath)</span>
}

// IncludeDirectory includes a directory (emulates user clicking include button)
func (f *IntegrationTestFramework) IncludeDirectory(dirPath string) <span class="cov8" title="1">{
        err := directories.IncludeDirectory(context.Background(), f.database, dirPath)
        require.NoError(f.t, err)
}</span>

// ExcludeDirectory excludes a directory (emulates user clicking exclude button)
func (f *IntegrationTestFramework) ExcludeDirectory(dirPath string) <span class="cov8" title="1">{
        err := directories.ExcludeDirectory(context.Background(), f.database, dirPath)
        require.NoError(f.t, err)
}</span>

// IncludeOrCreateDirectory includes a directory or creates it if missing
func (f *IntegrationTestFramework) IncludeOrCreateDirectory(dirPath string) <span class="cov8" title="1">{
        err := directories.IncludeOrCreateDirectory(context.Background(), f.database, dirPath)
        require.NoError(f.t, err)
}</span>

// AssertDirectoryIncluded checks that a directory is included (not excluded)
func (f *IntegrationTestFramework) AssertDirectoryIncluded(dirPath string) <span class="cov8" title="1">{
        dir, err := f.database.GetDirectory(context.Background(), "path = ?", directories.NormalizeDirectoryPath(dirPath))
        require.NoError(f.t, err)
        require.NotNil(f.t, dir, "Directory %s should exist", dirPath)
        assert.False(f.t, directories.IsExcluded(dir), "Directory %s should be included (not excluded)", dirPath)
}</span>

// AssertDirectoryExcluded checks that a directory is excluded
func (f *IntegrationTestFramework) AssertDirectoryExcluded(dirPath string) <span class="cov8" title="1">{
        dir, err := f.database.GetDirectory(context.Background(), "path = ?", directories.NormalizeDirectoryPath(dirPath))
        if err != nil </span><span class="cov8" title="1">{
                // If directory doesn't exist in database yet, it's effectively excluded
                assert.Contains(f.t, err.Error(), "record not found",
                        "Directory %s should either be excluded or not exist yet (which means excluded)", dirPath)
                return
        }</span>
        <span class="cov8" title="1">require.NotNil(f.t, dir, "Directory %s should exist", dirPath)
        assert.True(f.t, directories.IsExcluded(dir), "Directory %s should be excluded", dirPath)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
